{
    "name": "fortran-lang/fpm",
    "issues": [
        {
            "number": 88,
            "user": "LKedward",
            "date": "2020-05-31 10:23:57+00:00",
            "title": "Parallel job control flag",
            "text": "I think it's great that fpm already supports parallel builds - there should be a command line flag, like -j, to control the maximum number of threads used.\nThis is important for two reasons:\n\nyou can't assume that the machine will not already be under load, particularly for multi-user environments;\nmemory limits - I have previously run out of memory on a work computer for a large parallel build",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-01 02:19:40+00:00",
                    "text": "Yep, that's fair. -j is something that would be expected.\nI didn't mention this subtle detail, but I probably should have; it doesn't build the dependencies in parallel, but it absolutely could. By that I mean building two dependencies that don't depend on each other could be done simultaneously. However, doing that at this stage would mean that each dependency get's built with the same number of threads. I'll need to think about how to really robustly structure the parallelism."
                }
            ]
        },
        {
            "number": 87,
            "user": "everythingfunctional",
            "date": "2020-05-31 00:18:15+00:00",
            "title": "Docker Image With fpm",
            "text": "Now that fpm is in a usable state, I think we should try and create a docker image with the latest version installed, so people can use fpm in their CI.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-31 02:59:46+00:00",
                    "text": "Yes. Even better we should distribute fpm as a single binary for each platform."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-01 02:11:14+00:00",
                    "text": "I think we should focus more on package manager distributions than just an executable. At a minimum we should support apt, yum, pacman, and homebrew. Probably also some others. Manually installed things don't get updated very often, if at all."
                },
                {
                    "user": "certik",
                    "date": "2020-06-01 02:16:37+00:00",
                    "text": "Yes, we need all of those also.\n\u2026\nOn Sun, May 31, 2020, at 8:11 PM, Brad Richardson wrote:\n\n\n I think we should focus more on package manager distributions than just\n an executable. At a minimum we should support `apt`, `yum`, `pacman`,\n and `homebrew`. Probably also some others. Manually installed things\n don't get updated very often, if at all.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#87 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWAXGOLNFFNM2HC23I3RUME43ANCNFSM4NO5JRWQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-01 18:18:03+00:00",
                    "text": "Let's not forget fpm update. This is something I'd expect as a user. fpm should be able to update itself.\nI'm not a target audience for Docker image but I see its value.\nLinux system package managers like apt and dnf I use occasionally, but I can't take them seriously because so many packages are out of date, so they're mostly good for mature (stable) packages. I agree one should be able to get fpm using those. Then also consider Homebrew, Linuxbrew, and Snapcraft."
                }
            ]
        },
        {
            "number": 86,
            "user": "LKedward",
            "date": "2020-05-30 16:12:03+00:00",
            "title": "Support Fortran submodules",
            "text": "Except for small/simple projects, I almost always adopt Fortran submodules now to structure new projects. This is primarily for the parallel and incremental builds that they allow.\nI realise this may be low down on the list of project priorities currently, but I think it should only require an update to the dependency tracking whereby submodules depend on their parent modules as if they use them.\nMuch further down the line, I assume fpm will aim for some kind of parallel build support?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-30 16:14:52+00:00",
                    "text": "Thanks. Yes, fpm must work with submodules and yes, we must be able to build in parallel."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 19:55:20+00:00",
                    "text": "fpm does support parallel builds right now. All modules are compiled in parallel (to the extent they can be of course, given dependencies on the .mod files). Supporting submodules won't be too difficult, but I haven't found a particularly compelling use case."
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-30 20:01:22+00:00",
                    "text": "fpm does support parallel builds right now. All modules are compiled in parallel\n\nThis is awesome! I didn't realise. Does it use all available threads by default?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 23:04:41+00:00",
                    "text": "Yep"
                }
            ]
        },
        {
            "number": 85,
            "user": "everythingfunctional",
            "date": "2020-05-30 03:03:17+00:00",
            "title": "Implement test/executable specific dependencies",
            "text": "At this point it's kind of a terrible, ugly, hacked together prototype, but it works. And allows for \"semi\"-circular dependencies. If one of your test or executable dependencies depends on your library, it will still work.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 03:08:20+00:00",
                    "text": "My use case for this is that vegetables depends on both iso_varying_string and strff, but I want to be able to use vegetables to test them. This way that will work.\nI still need to try to migrate these to using fpm to be sure that it will work, but I'll try that over the next day or two. The test I added suggests it will."
                },
                {
                    "user": "certik",
                    "date": "2020-05-30 04:08:40+00:00",
                    "text": "Yes, we need this feature. However, let's follow the Cargo's syntax? Or do you have reasons why that's not a good idea in this case?\nhttps://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies\nIt has [dependencies] for just building the package, and additional [dev-dependencies] for building tests / benchmarks etc.\nCurrently you have:\n[[test]]\n  name = \"test\"\n  source-dir = \"tests\"\n  main = \"main.f90\"\n  [test.dependencies]\n    circular_test = { path = \"../circular_test\" }\nLet's instead do:\n[dev-dependencies]\n    circular_test = { path = \"../circular_test\" }\n\n[[test]]\n  name = \"test\"\n  source-dir = \"tests\"\n  main = \"main.f90\"\nAnd finally fpm should be clever enough to figure out the tests from the layout only (eventually), so it would become just:\n[dev-dependencies]\n    circular_test = { path = \"../circular_test\" }\nIn Cargo you can specify also dependencies for a particular target only. But it seems this dev-dependencies would cover 90% of use cases, including yours (I think)."
                },
                {
                    "user": "certik",
                    "date": "2020-05-30 04:09:43+00:00",
                    "text": "My other comment is that instead of adding tests in the root directory as examples, let's move them in the tests directory?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 19:41:26+00:00",
                    "text": "I'm not opposed to also having [dev-dependencies], but my question would be, are those used for the executables too? Or would we want to have [test-dependencies] and [exe-dependencies]?\nI can move the tests into the tests directory. That's no problem."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-31 00:16:34+00:00",
                    "text": "I was able to try this out converting a few of my libraries to using fpm, and it works great. This will make it possible for me to convert (almost) all of my packages to fpm."
                },
                {
                    "user": "certik",
                    "date": "2020-05-31 02:49:41+00:00",
                    "text": "I am not sure about the executables --- I would expect that dev-dependecies only work for tests, benchmarks etc.\nIn your use case, you have to have special dependencies for executables?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-31 23:20:53+00:00",
                    "text": "I don't personally have a project with special dependencies for an executable, but I could envision one. Somebody develops and tool, and there's a library that goes along with it, but the executable has dependencies that user's of the library don't necessarily need. The use case is probably rare enough, and covered by the executable/test specific dependencies I've already implemented that having dev-dependencies only for tests is probably fine. I'll get that implemented."
                },
                {
                    "user": "certik",
                    "date": "2020-05-31 23:35:10+00:00",
                    "text": "Yes, I think that's precisely the approach that Cargo took also. For this rare case, you just specify the dependency for the executable that needs it. Otherwise the dependencies and dev-dependencies cover over 90% of use cases.\n\nThanks for all the work you are doing on this.\n\u2026\nOn Sun, May 31, 2020, at 5:21 PM, Brad Richardson wrote:\n\n\n I don't personally have a project with special dependencies for an\n executable, but I could envision one. Somebody develops and tool, and\n there's a library that goes along with it, but the executable has\n dependencies that user's of the library don't necessarily need. The use\n case is probably rare enough, and covered by the executable/test\n specific dependencies I've already implemented that having\n `dev-dependencies` only for tests is probably fine. I'll get that\n implemented.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#85 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWCG44ZNP5I7MSX2U3LRULQ6BANCNFSM4NOQBL6A>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-01 16:32:06+00:00",
                    "text": "Sorry, I don't have time to review this but please go forward with it and I will play with it at a later time."
                }
            ]
        },
        {
            "number": 84,
            "user": "certik",
            "date": "2020-05-29 18:14:25+00:00",
            "title": "Optional dependencies",
            "text": "It is extremely common to have optional dependencies in Fortran projects (see the examples section at the end of this description).\nThe way Cargo handles it is described in here: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html\n[dependencies]\nfoo = { version = \"1.0\", optional = true }\nbar = { version = \"1.0\", optional = true }\n\n[features]\nfancy-feature = [\"foo\", \"bar\"]\nit seems it is somehow tied to \"features\" that one can enable somehow, but I don't yet understand the full mechanism. Also there must be some way to propagate this \"feature\" on/off status inside the code using some macros or something.\nIn Fortran, I can see at least two ways to implemented it, are there more?\n\n\nWe can define some pre-processor definitions and use #ifdef to enable certain code if an optional dependency is used. We can support multiple pre-processors (cpp, fypp, ...).\n\n\nOne can do it at the module level: I sometimes have two files, say, openmp.f90 and openmp.dum.f90 both of which implement the openmp module, so the rest of the Fortran code just use openmp no matter what, and only one of the two files is compiled and linked in the buildsystem:\n# OPENMP\nif(WITH_OPENMP)\n    set(SRC ${SRC}\n        openmp.f90\n    )\nelse()\n    set(SRC ${SRC}\n        openmp.dum.f90\n    )\nendif()\n\n\nThe advantage of 2. is that you do not have to use any pre-processor, which I try to avoid in my codes. The advantage of 1. is that it's simpler in some ways, you just put a few ifdefs in your code.\nI think fpm can support either one, or both.\nfpm could for example create some module, say optional_dependencies and export some variable or a function such as openmp_enabled for the \"openmp\" feature, that you can call in your code and make some decisions.\nEither way, we should figure out how to make fpm support optional dependencies and features that the user can configure.\nExamples\nExample 1\nA typical example is a large electronic structure code, that provides its own default exchange correlation functional, but optionally allows to link against the libxc library, in which case one must enable and link against it and some code paths are different (typically some Fortran modules are enabled / disabled) and it allows the code to use functionals from the libxc library.\nExample 2\nThere are many linear and eigensolver libraries, and there is typically some default, but if the user installs a particular 3rd party solver, it can optionally enable it in the Fortran program to use it instead.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-29 19:36:50+00:00",
                    "text": "I would lean towards option 1 as being easier to implement in fpm. It just doesn't fetch and build optional dependencies unless specified, and only defines the environment variables for the ones specified.\nWith option 2, the build process has to be able to make decisions about which source file gets used to satisfy a given module. This requires us to modify/extend our current naming conventions with regards to source file name and module name.\nI definitely see the need for such a feature, and I think we should definitely try and tackle this at some point."
                }
            ]
        },
        {
            "number": 83,
            "user": "certik",
            "date": "2020-05-24 00:56:44+00:00",
            "title": "Add tests",
            "text": "Currently the new fpm does not seem to have any tests. We have to fix it, and start adding lots of tests.\nIn the old fpm, I had two initial tests:\nhttps://github.com/fortran-lang/fpm/tree/master/archive/tests\nAnd we need to add a lot more. The idea would be to test any configuration that is supported, and that way we can ensure that it works and things don't break when new functionality is implemented.\nFurthermore, if we decide to use a different language for the production implementation, the tests will allow us to ensure that the new implementation works as expected.",
            "comments": []
        },
        {
            "number": 82,
            "user": "everythingfunctional",
            "date": "2020-05-23 17:35:14+00:00",
            "title": "Enable dependencies",
            "text": "This makes working with git dependencies possible!\nSee an example project I create here.\nIt's still very raw, but should work for a lot of situations.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-05-23 19:40:39+00:00",
                    "text": "Great, I'm excited to play with it.\n\nIt's still very raw, but should work for a lot of situations.\n\nAt this time, do you know what situations don't work?"
                },
                {
                    "user": "certik",
                    "date": "2020-05-24 01:00:15+00:00",
                    "text": "Great work, thanks for adding this Brad!\nWe really need to start adding tests for every PR, see #83.\nFor this particular PR, what is the best way to test this? It might be quite hard to setup a test server and download using it, all automatically when running tests. The way I was thinking we can test this is to add support for specifying a dependency that lives on a local filesystem. That way we can simply test it locally, without setting up some test servers."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-24 03:19:07+00:00",
                    "text": "@milancurcic , I think it may still have an issue trying to build if there is a circular dependency. You'll probably hit an infinite loop. But I haven't tested that.\n@certik , Agreed. I'm thinking of going ahead and adding path dependencies, and then yes, you can just test it locally. Really the only way to test whether stuff that needs to go over the network works is to let it go over the network. Otherwise you have to figure out how to supply a \"dummy network\" when working under tests.\nI think at this point, the best tests are going to be beta testers. I'm going to try and migrate a few of my projects to use it and see how it goes. Long term we could take the Rust/Cargo approach and just try to build all the libraries in the registry with every new version. Not sure how feasible that is, but it would at least guarantee we never break any existing packages."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-24 16:10:30+00:00",
                    "text": "I'm getting a stack error building this:\n$ git clone https://github.com/everythingfunctional/fpm -b EnableDependencies\nCloning into 'fpm'...\nremote: Enumerating objects: 172, done.\nremote: Counting objects: 100% (172/172), done.\nremote: Compressing objects: 100% (108/108), done.\nremote: Total 718 (delta 69), reused 132 (delta 45), pack-reused 546\nReceiving objects: 100% (718/718), 123.66 KiB | 981.00 KiB/s, done.\nResolving deltas: 100% (303/303), done.\n$ cd fpm/\n$ stack build\nAeson exception:\nError in $.packages[0].completed: failed to parse field 'packages': failed to parse field 'completed': Could not parse a UnresolvedPackageLocationImmutable from: Object (fromList [(\"name\",String \"tomland\"),(\"version\",String \"1.3.0.0\"),(\"git\",String \"https://github.com/kowainik/tomland.git\"),(\"pantry-tree\",Object (fromList [(\"size\",Number 5000.0),(\"sha256\",String \"68d6f9a3e4c20cc4645374b30000017a75c4ab1c131590538edad2ea0e4a53bd\")])),(\"commit\",String \"536a5e6ffb148d0dd4e4c4b120913a6744097676\")])\n\nMaster builds fine. I poked around a little bit and found that if I remove stack.yaml.lock, stack build works as expected.\nShould stack.yaml.lock then be removed from the repo?\nOtherwise, it works great. I made a simple program that fetches datetime and prints current time on the screen:\n$ cat fpm.toml \nname = \"current-time\"\n\n[dependencies]\ndatetime = {git = \"https://github.com/wavebitscientific/datetime-fortran\"}\n$ cat app/main.f90 \nuse datetime_module, only: datetime\ntype(datetime) :: a\na =  a % now()\nprint *, a % strftime('%d %B %Y %H:%M:%S')\nend"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-25 02:09:30+00:00",
                    "text": "I'm getting a stack error building this:\n$ git clone https://github.com/everythingfunctional/fpm -b EnableDependencies\nCloning into 'fpm'...\nremote: Enumerating objects: 172, done.\nremote: Counting objects: 100% (172/172), done.\nremote: Compressing objects: 100% (108/108), done.\nremote: Total 718 (delta 69), reused 132 (delta 45), pack-reused 546\nReceiving objects: 100% (718/718), 123.66 KiB | 981.00 KiB/s, done.\nResolving deltas: 100% (303/303), done.\n$ cd fpm/\n$ stack build\nAeson exception:\nError in $.packages[0].completed: failed to parse field 'packages': failed to parse field 'completed': Could not parse a UnresolvedPackageLocationImmutable from: Object (fromList [(\"name\",String \"tomland\"),(\"version\",String \"1.3.0.0\"),(\"git\",String \"https://github.com/kowainik/tomland.git\"),(\"pantry-tree\",Object (fromList [(\"size\",Number 5000.0),(\"sha256\",String \"68d6f9a3e4c20cc4645374b30000017a75c4ab1c131590538edad2ea0e4a53bd\")])),(\"commit\",String \"536a5e6ffb148d0dd4e4c4b120913a6744097676\")])\n\nMaster builds fine. I poked around a little bit and found that if I remove stack.yaml.lock, stack build works as expected.\nShould stack.yaml.lock then be removed from the repo?\nOtherwise, it works great. I made a simple program that fetches datetime and prints current time on the screen:\n$ cat fpm.toml \nname = \"current-time\"\n\n[dependencies]\ndatetime = {git = \"https://github.com/wavebitscientific/datetime-fortran\"}\n$ cat app/main.f90 \nuse datetime_module, only: datetime\ntype(datetime) :: a\na =  a % now()\nprint *, a % strftime('%d %B %Y %H:%M:%S')\nend\n\n\nThat's odd. stack.yaml.lock is supposed to ensure that exactly the same dependency versions get used for everybody. It looks like something went funky with the specific version of tomland that I specified. What is the difference in that file after you removed it and rebuilt?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-25 18:02:06+00:00",
                    "text": "$ diff stack.yaml.lock stack.yaml.lock.orig \n8,10d7\n<     cabal-file:\n<       size: 6802\n<       sha256: 85568a0280115b6e9a9f263cf4cfc72ad5a6eaeb2412875816adb82ea6a405bc\n\nstack.yaml.lock.orig is the one checked out from the repo. stack.yaml.lock is the one generated by stack build.\nI don't understand how is this related to the specific tomland version \ud83d\ude15\nFWIW, I reproduced this on Fedora 28 and Ubuntu 18.10."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-25 18:44:08+00:00",
                    "text": "It looks like the difference in the files is in the tomland section, and the error message you got mentions tomland. So that's where the problem is, but I'm still not sure why. I'm on Arch running version 2.3.1 of stack. Maybe the format/info in the stack.yaml.lock versions has changed slightly?\nI can remove it for now, since things work without it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-25 18:55:22+00:00",
                    "text": "Sounds good, this can be merged IMO."
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:02:22+00:00",
                    "text": "Here is the error that I am getting with d89214b on Ubuntu 18.04:\n$ stack build\nAeson exception:\nError in $.packages[0].completed: failed to parse field 'packages': failed to parse field 'completed': Could not parse a UnresolvedPackageLocationImmutable from: Object (fromList [(\"name\",String \"tomland\"),(\"version\",String \"1.3.0.0\"),(\"git\",String \"https://github.com/kowainik/tomland.git\"),(\"pantry-tree\",Object (fromList [(\"size\",Number 5000.0),(\"sha256\",String \"68d6f9a3e4c20cc4645374b30000017a75c4ab1c131590538edad2ea0e4a53bd\")])),(\"commit\",String \"536a5e6ffb148d0dd4e4c4b120913a6744097676\")])\n\nWith 1cb711d things build fine.\nThe lock file, at least for Rust, is supposed to be checked into git for applications but not libraries. fpm would be an application."
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:03:20+00:00",
                    "text": "As a side note, since fpm is following the same design as Stack and Cargo: I want fpm's error messages to be much nicer and more user friendly than the above exception that Stack gives. :)"
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-25 19:28:13+00:00",
                    "text": "Aren't you are supposed to recommit the lock file whenever you add/update dependencies - @everythingfunctional is the tomland dependency new in this PR?"
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:31:17+00:00",
                    "text": "Yes, you are supposed to regenerate it when dependencies change. The tomlang dep seems to be new here?\nhttps://github.com/fortran-lang/fpm/pull/82/files#diff-fafd0cdcd559a7b124cc61c29413fb54R42"
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:34:39+00:00",
                    "text": "When I commit the new lock file that got generated for me, and diff the old one, here is what I get:\n$ git diff d89214b\ndiff --git a/stack.yaml.lock b/stack.yaml.lock\nindex 31e0c19..15bfc22 100644\n--- a/stack.yaml.lock\n+++ b/stack.yaml.lock\n@@ -5,6 +5,9 @@\n \n packages:\n - completed:\n+    cabal-file:\n+      size: 6802\n+      sha256: 85568a0280115b6e9a9f263cf4cfc72ad5a6eaeb2412875816adb82ea6a405bc\n     name: tomland\n     version: 1.3.0.0\n     git: https://github.com/kowainik/tomland.git\nFurthermore, when I remove those 3 lines by hand, I get the exception above.\nFrom this I conclude that the lock file should be committed, and it should contain the above 3 lines."
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:42:19+00:00",
                    "text": "I pushed in the lock file again. Things work on my machine and tests pass at the CI.\n@everythingfunctional can you verify that things work on your machine also with the latest commit 3613167?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-25 19:51:50+00:00",
                    "text": "Any ideas why the CI tests were not affected by this lock file problem?"
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 20:07:51+00:00",
                    "text": "Any ideas why the CI tests were not affected by this lock file problem?\n\nExactly, this worries me too that our CI passed even though the lock file was broken. Possibly the CI uses a different Haskell version?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-25 20:56:23+00:00",
                    "text": "I suspect my machine and the CI are using a newer version of stack, which does not need those 3 lines in the stack.yaml.lock file. @certik , your latest push does work on my machine.\nYes, the .lock file should generally be checked in to version control. It's generally ignored for dependencies, (i.e. if a library has this file, when you include it as a dependency, that file doesn't even get looked at). It's purpose is to avoid having to consider different versions of dependencies when trying to diagnose \"works on my machine\" type issues. Stack is able to make sure you're using the exact same dependencies of everything your project uses, including the version of GHC (the Haskell compiler), except for the version of Stack itself. It seems to me that's the only possible explanation here.\n@LKedward , the dependency on tomland isn't new here, but I had to implement some new functionality in that library, and it hasn't made it to an official release yet, so I had to specify it as a git dependency. That part is new here."
                },
                {
                    "user": "certik",
                    "date": "2020-05-28 20:43:47+00:00",
                    "text": "Thanks for merging."
                }
            ]
        },
        {
            "number": 81,
            "user": "ShamanTcler",
            "date": "2020-05-19 12:59:23+00:00",
            "title": "Understanding intent",
            "text": "This is more of a discussion than an issue.\nAs a developer who routinely develops in FORTRAN and  C, I have come across Conan, http://conan.io a C/C++ package manager.\nNow in my mind C and FORTRAN are very similar in character ... both have attributes such as:\n\ncompilers\n\ncompiler vendors\ncompiler versions\ncompiler flags\n\n\nbitness (32 vs 64)\ndebug/release builds\n\nEtc.\nConan manages these very well via a hash assigned to the package.\nNow I tried about two years ago to implement a similar scheme, to what Conan was doing but finally said ... they just do it better.\nToday I use VS Code, CMake/Ninja and Conan as my \"best practice\". ( BTW, the new Ninja version 10.  native support for FORTRAN modules ) This set up supports Intel FORTRAN/GFORTRAN and hopefully FLANG soon\nSo I am curious what do you think you bring new to the table.\nPlease don't think I am just throwing stones ... I have hundreds of thousands of lines of FORTRAN code, and Conan is bit of a \"force fit\", but not bad,  ... so I truly am looking to improve my best practice.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-05-19 13:42:12+00:00",
                    "text": "Hi @ShamanTcler and welcome! Thank you for starting this discussion.\nHere's an excerpt from an email I sent to colleagues a few days ago. It's my answer to your question.\nfpm solves the (1) user and (2) developer experience problem. I don't think it solves any technical problem. How it's implemented under the hood is details, and there are many different roads we can take. But in the design of fpm we focus on UI and UX.\n\nUser experience: Once fpm is installed, all that the user has to do is fpm build, fpm run, fpm test, or fpm install. This is by far the simplest UI for Fortran out there, and is aligned to what Cargo does (we designed it after Cargo exactly with UX in mind). So the only friction comes down to installing fpm. If we make this seamless--single binary executable to download--then we'll have reduced the friction to near minimum.\n\nThe key solution for here is that the user doesn't have to a) download the source code by hand; b) edit any build files; and c) download and build any dependencies by hand.\n\nDeveloper experience: See this doc that describes the layout of an fpm package. As you can see, we take the sane default approach like Cargo where we assume a package layout and file and module naming conventions. So the developer has to remember/learn only where to put the files and how to name them. As far as I'm aware, this is the simplest developer UI for Fortran out there. Plus, the developer also gets the perk from the user experience above, which is that dependencies are automatically downloaded, built, and linked for you.\n\nAs you know, there are tools that collectively do all of the stuff that I described. However, there's no single tool that does all of what we want, and no more. Most tools were designed and intended as \"the one build system/package manager to rule them all\". They all fail because this is an extremely difficult problem. They also tend to be language agnostic (or at least support several different languages), so they necessarily have to be more general and handle more edge cases, which means more complex, and more complicated for the user.\nAnother great developer recently said \"we don't need another language-specific tool\". I think that's exactly what we need. Language-agnostic is what makes a tool become either too general and complex, or the design gets out of hand to reach all its objectives. Cargo is perfect for Rust. We need Cargo for Fortran.\nThere's also a cultural and aesthetic aspect that people rarely bring up. It's very difficult to convince a community of developers to adopt exclusively Conda, CMake, Meson, Ninja, or whatever. Conda is maybe becoming a household name in scientific Python community, but CMake is far from being a household name for Fortran. If there's a household name for Fortran, that would maybe be autotools + Make, and that's just Linux. Yes, I'm mixing up build systems and package managers here, but I'm trying to make a point, which is that we need a household name. We need a tool that, when a newcomer to Fortran visits fortran-lang.org, we can tell them here is the one tool you should use. This will only work if we have mass buy in from the community, and I think we can do this more easily if we build a Fortran-specific build system + package manager in a single tool, than trying to adopt multiple external tools.\nIt's easy for you and me and most people here to say \"why do you need this when there are already tools X, Y, and Z\". I consider myself technically literate, and I'd walk away from a project if it asked me to install Meson or Ninja. I've walked away before from Python packages that only had the Conda install instruction, and were not installable by pip. That's just me. Now imagine how it is for somebody new to Fortran, not to mention somebody new to programming.\nWe are targeting Fortran users across all skill levels, and especially the entry level programmers. I think it's crucial for Fortran that a new programmer who learns Fortran as their first language, loves the experience and is not scared off.\nThe Fortran build system + package manager must be at least as easy (and should be easier) to install and use, than it is to install and use the compiler directly.\n\nTake a look at Fortran Discourse. I think it's the perfect format for discussions like this."
                },
                {
                    "user": "ShamanTcler",
                    "date": "2020-05-19 14:42:45+00:00",
                    "text": "Thanks for the link to \"FORTRAN Discourse\" ... already joined. ( user CandL there)\nI see mention of FORTRANCon  ... good 'ole Steve Lionel is the key note, should be a good show.\nYour comment \"I consider myself technically literate, and I'd walk away from a project if it asked me to install Meson or Ninja.\" leaves me a bit perplexed ... at least regarding Ninja. I am sure this could lead to an interesting evening over a few adult beverages of your choice.\nBut I agree the discourse area is a better spot for this discussion. Thanks for your time and consideration.\nRegards\nCarl"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-19 15:22:40+00:00",
                    "text": "Your comment \"I consider myself technically literate, and I'd walk away from a project if it asked me to install Meson or Ninja.\" leaves me a bit perplexed ... at least regarding Ninja.\n\nYes, a bit of a hyperbole. If I need the project to get work done, sure. If I'm just playing, I'd pass. From Ninja's landing page, I'm not clear how it can help me. From the manual, it sounds like a faster Make. So, a tool for power users.\n\nI am sure this could lead to an interesting evening over a few adult beverages of your choice.\n\nI hope we get a chance to do it soon! :)"
                }
            ]
        },
        {
            "number": 80,
            "user": "milancurcic",
            "date": "2020-05-17 20:20:24+00:00",
            "title": "Install dependencies from remote git URLs",
            "text": "As discussed in #33, let's allow installing fpm-enabled packages form their git repositories.\nIf the following is placed in fpm.toml:\n[dependencies]\ndependency_name = { git = git_url, tag = git_tag }\nThen the package depends on dependency_name, which fpm will fetch from git_url and a specific git tag git_tag.\nHere's a concrete example that will work, when this issue is implemented.\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\", tag = \"v1.7.0\" }\nQuestion: If tag is omitted, should fpm fetch from the latest commit on master? I think so. Cargo does it like that as well. Then you could also do:\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\" }",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-17 20:23:03+00:00",
                    "text": "This is exactly my plan."
                },
                {
                    "user": "certik",
                    "date": "2020-05-17 21:05:04+00:00",
                    "text": "Yes, if tag is omitted, it should check out the latest master.\nOtherwise I agree."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-01 17:46:14+00:00",
                    "text": "This was finished in #85"
                }
            ]
        },
        {
            "number": 79,
            "user": "certik",
            "date": "2020-05-14 19:48:36+00:00",
            "title": "Easily create a Spack package",
            "text": "This issue is similar to #70 but for Spack instead of Conda. Essentially for people that use Spack (myself included sometimes), it would be nice to just be able to spack install any fpm package.\nTo do that, fpm should be able to take any package and produce a working Spack package out of it, that can then be submitted to Spack.\nThe generated Spack package would probably call fpm underneath to do the build.",
            "comments": []
        },
        {
            "number": 78,
            "user": "LKedward",
            "date": "2020-05-12 12:35:32+00:00",
            "title": "Preprocessor support",
            "text": "This issue is to ask whether fpm will have any built-in support for preprocessing and how this might look.\nI bring this up since I noticed that stdlib is listed in #17 under 'Pure Fortran', however it requires the fypp preprocessor to build from repo source.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-12 14:18:26+00:00",
                    "text": "We've had discussions about it. I believe we decided we want to settle on a preprocessor, and just always use it. I'd have to go find that discussion, but I believe we settled on fypp."
                },
                {
                    "user": "certik",
                    "date": "2020-05-12 14:49:08+00:00",
                    "text": "Yes, we definitely want fpm to apply a preprocessor. We also talked about file extensions, and it seems most people would prefer to just stick with .f90, and fpm would apply the preprocessor appropriately (via a compiler option or otherwise).\nWe probably should support both cpp and fypp. For fypp we should further provide a fast C++ implementation, so that we don't have to depend on Python."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-12 15:23:04+00:00",
                    "text": "\ud83d\udc4d on both cpp and fypp. cpp is de facto standard and many Fortran projects rely on it. fypp we have established earlier that it is more powerful than cpp and thus useful for generation of specific procedures like those in stdlib.\n\nFor fypp we should further provide a fast C++ implementation, so that we don't have to depend on Python.\n\nI agree, although this is a non-issue until fpm itself is Fortran or C++. Python ships out of the box on most systems."
                },
                {
                    "user": "certik",
                    "date": "2020-05-12 15:33:39+00:00",
                    "text": "I agree, although this is a non-issue until fpm itself is Fortran or C++.\n\nActually it's an issue for distributing fpm, as we cannot easily integrate fypp into the fpm single binary, so we now have to ship it along side fpm somehow, etc.\nHowever, since we will eventually use Conda for the non Fortran dependencies, then fypp can just be installed using Conda / Mamba, and then indeed it should become a non-issue."
                }
            ]
        },
        {
            "number": 77,
            "user": "milancurcic",
            "date": "2020-05-10 18:20:20+00:00",
            "title": "Should we refer to this software as FPM or fpm?",
            "text": "They mean the same, but they look and \"feel\" different. We should have a consistent way to refer to this so it's not confusing to the readers whether they're different things. Especially as we begin to write about these things more publicly?\nI've been using both. I don't know which one I prefer. Perhaps 60/40 in favor of fpm.\nSo, which one should it be?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-10 18:24:29+00:00",
                    "text": "I've been using both also. Let's use lowercase.\n\nI think fpm, with `fpm` in markdown. Just like git or markdown.\n\nIf it is at the beginning of a sentence, let's use Fpm.\n\u2026\nOn Sun, May 10, 2020, at 12:20 PM, Milan Curcic wrote:\n\n\n They mean the same, but they look and \"feel\" different. We should have\n a consistent way to refer to this so it's not confusing to the readers\n whether they're different things. Especially as we begin to write about\n these things more publicly?\n\n I've been using both. I don't know which one I prefer. Perhaps 60/40 in\n favor of fpm.\n\n So, which one should it be?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#77>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWDU4C2JEGTK7CN6IJTRQ3V7BANCNFSM4M5LDRPA>."
                },
                {
                    "user": "certik",
                    "date": "2020-05-10 18:31:19+00:00",
                    "text": "I guess git uses both Git and git: https://git-scm.com/\n\nI think svn also uses both SVN and svn.\n\nI am fine either way.\n\nWe can have a rule to use FPM when referencing the project, but fpm when the executable, and encourage to use fpm where it make sense. But should we write Fortran Package Manager (FPM) or Fortran Package Manager (fpm) at the top of the website?\n\nOndrej\n\u2026\nOn Sun, May 10, 2020, at 12:24 PM, Ond\u0159ej \u010cert\u00edk wrote:\n I've been using both also. Let's use lowercase.\n\n I think fpm, with `fpm` in markdown. Just like git or markdown.\n\n If it is at the beginning of a sentence, let's use Fpm.\n\n On Sun, May 10, 2020, at 12:20 PM, Milan Curcic wrote:\n >\n >\n > They mean the same, but they look and \"feel\" different. We should have\n > a consistent way to refer to this so it's not confusing to the readers\n > whether they're different things. Especially as we begin to write about\n > these things more publicly?\n >\n > I've been using both. I don't know which one I prefer. Perhaps 60/40 in\n > favor of fpm.\n >\n > So, which one should it be?\n >\n > \u2014\n > You are receiving this because you are subscribed to this thread.\n > Reply to this email directly, view it on GitHub\n > <#77>, or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWDU4C2JEGTK7CN6IJTRQ3V7BANCNFSM4M5LDRPA>.\n >"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-10 18:59:39+00:00",
                    "text": "Node Package Manager uses npm universally. Even the company is called \"npm, Inc.\".\nI vote for fpm all the way, and fpm when referring specifically to the command line executable."
                },
                {
                    "user": "certik",
                    "date": "2020-05-10 19:14:26+00:00",
                    "text": "I also vote fpm all the way.\n\u2026\nOn Sun, May 10, 2020, at 12:59 PM, Milan Curcic wrote:\n\n\n Node Package Manager <https://www.npmjs.com/> uses npm universally.\n Even the company is called \"npm, Inc.\".\n\n I vote for fpm all the way, and `fpm` when referring specifically to\n the command line executable.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#77 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWH4JET6LJBKTX7JHJLRQ32SNANCNFSM4M5LDRPA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 02:19:29+00:00",
                    "text": "I can come up with logical arguments for either.\nOn the one hand, it's a proper noun, Fortran is capitalized, and it's an acronym, so FPM would make sense.\nOn the other hand, Fortran is a case insensitive language, and our community style guide seems to be leaning towards all lowercase, so fpm would be consistent with that.\nGiven that this really is a purely aesthetic choice, and there seems to be a trend in other places towards all lowercase, I have nothing against using fpm everywhere. I'll start doing that."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-17 20:09:08+00:00",
                    "text": "The consensus so far is to use \"fpm\" everywhere. Closing."
                }
            ]
        },
        {
            "number": 76,
            "user": "everythingfunctional",
            "date": "2020-05-10 04:15:33+00:00",
            "title": "Prefix library archive file names with lib",
            "text": "Fix #75",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-10 05:01:32+00:00",
                    "text": "+1, looks good\n\u2026\nOn Sat, May 9, 2020, at 10:15 PM, Brad Richardson wrote:\n\n\n @everythingfunctional <https://github.com/everythingfunctional>\n requested your review on: #76\n <#76> Prefix library archive\n file names with lib.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#76 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWC2J6GTOZI5TTUQDW3RQYS7BANCNFSM4M5CPJ6A>."
                }
            ]
        },
        {
            "number": 75,
            "user": "milancurcic",
            "date": "2020-05-09 20:22:10+00:00",
            "title": "Add lib prefix to the static library file name",
            "text": "Currently, FPM emits a static library file that has the same name as the project. For example, first line of fpm.toml could be:\nname = \"datetime\"\nThen, the static library created is datetime.a. However, the canonical way to name libraries (static and dynamic) is to use a lib prefix: libdatetime.a. Then one can link to this library with -ldatetime.\nCurrent workaround can be to add the lib prefix to the package name in fpm.toml:\nname = \"libdatetime\"\nHowever, this isn't pretty, and would down the road be more awkward once we're installing packages from remote URLs.\nLet's add the lib prefix to library files.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-09 21:25:13+00:00",
                    "text": "I agree.\n\u2026\nOn Sat, May 9, 2020, at 2:22 PM, Milan Curcic wrote:\n\n\n Currently, FPM emits a static library file that has the same name as\n the project. For example, first line of `fpm.toml` could be:\n\n name = \"datetime\"\n Then, the static library created is `datetime.a`. However, the\n canonical way to name libraries (static and dynamic) is to use a `lib`\n prefix: `libdatetime.a`. Then one can link to this library with\n `-ldatetime`.\n\n Current workaround can be to add the `lib` prefix to the package name\n in `fpm.toml`:\n\n name = \"libdatetime\"\n However, this isn't pretty, and would down the road be more awkward\n once we're installing packages from remote URLs.\n\n Let's add the `lib` prefix to library files.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#75>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWETEZUJY7Q5QWRYIYTRQW3P3ANCNFSM4M46DEDQ>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-10 03:41:20+00:00",
                    "text": "I see. This is a simple enough change to make. I will note however that FPM is just including the archive directly in the link command, rather specify both -Ilib/folder and -lname arguments. So this will only impact users doing things outside of FPM. Granted that many people will want to do things outside of FPM, I think it makes sense to go ahead and do it."
                }
            ]
        },
        {
            "number": 74,
            "user": "everythingfunctional",
            "date": "2020-05-04 02:55:33+00:00",
            "title": "Add compiler to build path",
            "text": "This is the first part of supporting #66\nNote: This should be merged after #72",
            "comments": []
        },
        {
            "number": 73,
            "user": "everythingfunctional",
            "date": "2020-05-04 02:35:09+00:00",
            "title": "Output a message if no executables or tests are found",
            "text": "Fix #64",
            "comments": []
        },
        {
            "number": 72,
            "user": "everythingfunctional",
            "date": "2020-05-04 02:22:15+00:00",
            "title": "Remove compiler option from `fpm.toml`",
            "text": "Fix #63",
            "comments": []
        },
        {
            "number": 71,
            "user": "epagone",
            "date": "2020-05-03 17:20:05+00:00",
            "title": "Install app or library system-wide",
            "text": "I know it might be a bit early but I'd like to log this issue that is particularly important for me.\nTo use routinely fpm, I would need a functionality that works a bit like sudo make install to install the executable or library system-wide.\nPS: thanks for your great work!",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-03 21:16:09+00:00",
                    "text": "@epagone thanks! Yes, we have to do it.\n@everythingfunctional how can one do that using stack install? I read through stack install --help but didn't see an option to install into /usr/local/bin/."
                },
                {
                    "user": "epagone",
                    "date": "2020-05-03 22:58:47+00:00",
                    "text": "I read through stack install --help but didn't see an option to install into /usr/local/bin/.\n\nFor the records, on Ubuntu 20.04, if I copy manually my library files (libsomething.a) in /usr/local/lib/ or /usr/lib, gfortran finds it with $ gfortran libtest.f90 -lsomething.\nHowever, copying the module files to /usr/local/include does not work and the full path must be specified after the -I flag: $ gfortran libtest.f90 -lsomething -I/usr/local/include\nPS: sorry for having repeatedly edited my message, but I have been experimenting a bit and I didn't want to leave confusing or contradictory messages around."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-04 02:16:33+00:00",
                    "text": "I think having an install functionality is definitely desired. I believe with stack, stack install is just for executables. I'd lean towards doing the same thing with FPM. I can easily see the desire to install an executable, but I'm not sure I fully understand the benefits of having FPM install libraries.\nFor installing libraries, I tend to lean on the side of not doing anything that goes around the system package manager, since there's a decent chance of breaking things. Also, FPM is compiling archives, not shared object libraries. And if you're using FPM, you don't need to have the library installed on your system in order for other packages to use it. That's whole point of FPM.\nI'm not completely opposed to the idea, but I would need somebody to show me a use case that would constitute good practice. I'd rather FPM not try and also take on the role of system package manager. I think twice about anything that needs sudo to do it."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 04:38:39+00:00",
                    "text": "Ah, I missed this point: this is about fpm installing the apps and libraries systemwide.\nWhy don't we start with what Cargo does via cargo install --root ... which however is for Cargo managed packages, and then we see what else we can do. I think installing apps that are statically linked should be no problem.\nFinally, that's a good point that if fpm is to become a usable replacement for CMake (let's say), it must be able to install the executables and libraries to a user defined location.\n(Most probably we'll have to be able to build both static and dynamic libraries with fpm down the road.)"
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-04 07:47:24+00:00",
                    "text": "For installing libraries, I tend to lean on the side of not doing anything that goes around the system package manager, since there's a decent chance of breaking things.\n\nThe Linux file system has a well-defined segregation between files installed by package managers and those built by users; as @epagone mentioned user-built executables/libraries/headers go in /usr/local/bin /usr/local/lib (both shared and static) and /usr/local/include. This is a common target for makefiles for c libraries and avoids the need to specify include and library paths when compiling and linking.\nHowever this approach can't be used for Fortran libraries because:\n\n\nUnlike c, Fortran has no application binary interface which means that compiled libraries are specific to the compiler and compiler version that compiled it.\n\n\nThere is no agreed-upon location to place (and search for) the requisite .mod files, which are also binary-specific to the compiler and compiler version that generated them.\n\n\nI agree with @everythingfunctional that one of the goals of fpm is to solve this problem for us; specifically, it handles module paths and linker library paths for us in a robust and repeatable manner (which is the main advantage of installing system-wide IMO).\nI think install functionality for executables is a natural functionality, I would like:\n\n(sudo) fpm install for /usr/local/bin and;\nfpm install --local for $HOME/.local/bin"
                },
                {
                    "user": "epagone",
                    "date": "2020-05-04 10:10:17+00:00",
                    "text": "@everythingfunctional\n\nI think having an install functionality is definitely desired. I believe with stack, stack install is just for executables. I'd lean towards doing the same thing with FPM. I can easily see the desire to install an executable, but I'm not sure I fully understand the benefits of having FPM install libraries.\nFor installing libraries, I tend to lean on the side of not doing anything that goes around the system package manager, since there's a decent chance of breaking things. Also, FPM is compiling archives, not shared object libraries. And if you're using FPM, you don't need to have the library installed on your system in order for other packages to use it. That's whole point of FPM.\n\nSorry, but I do not understand. Let's take this example: I have a string manipulation library that I build from source pulling a GitHub repo. I need this library in almost all of my many projects. I think it's obvious to expect from the package manager the ability to make the library available system-wide. (FWIW, I am not using FoBiS exactly because it lacks this functionality.) Am I doing something wrong in my development procedures?\n@LKedward\n\nHowever this approach can't be used for Fortran libraries because:\n1. Unlike c, Fortran has no application binary interface which means that compiled libraries are specific to the compiler and compiler version that compiled it.\n\n2. There is no agreed-upon location to place (and search for) the requisite `.mod` files, which are also binary-specific to the compiler and compiler version that generated them.\n\n\nOuch. Thanks for this explanation, but it's really a bad news! \ud83d\ude1e"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-04 14:29:36+00:00",
                    "text": "I need this library in almost all of my many projects.\n\nIf you're using FPM, then it has the responsibility to provide the appropriate version to compile and link with your project. It does not rely on whatever version happens to be installed on your system.\nSay for example, the latest version of a library introduced a breaking change that your project relies on. You can continue using the old version for your old project, but use the latest version in your new project, on the same machine, and not have any issues."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 15:22:18+00:00",
                    "text": "@epagone wrote:\n\nI think it's obvious to expect from the package manager the ability to make the library available system-wide.\n\nYes, that's the goal. Fpm must have an option to install a library systemwide or to any location you want."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-04 15:35:54+00:00",
                    "text": "I also think it's important to allow both static and dynamic library builds down the road.\nIf I understand this correctly, it seems to me that the high-level debate here is whether fpm should work only within the context of a local, package-specific environment (@everythingfunctional position I think), vs. whether fpm could also install to places elsewhere on the system (regardless whether it's a root or user directory).\nIf you always worked in the package-specific environment, that means that you'd need to rebuild the same dependency for every project that uses it, rather than re-use an existing build. I don't know if Cargo for example can build system-wide, but its canonical behavior is to rebuild everything per-project. For example if you try a demo database or web-server project in Rust, you'll first be building all the 500 dependencies that it needs.\nBesides the rationale others already provided, another advantage to this is that some libraries take some time to build (for example NetCDF). Rebuilding them for every new project would hurt user experience.\nI think both approaches should be possible. Default should be like Cargo. How about this UI:\n\nFor in-package build, fpm build suffices, no need for fpm install. The library is already installed in build/... in the package directory.\nFor install elsewhere, fpm install installs to a sane default user location, perhaps /home/user/.fpm/{bin,lib,include}.\nFor install to a specific place, fpm install --prefix=/path/to/install."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 15:48:08+00:00",
                    "text": "I agree with @milancurcic's proposal at the end.\nLet's start with rebuilding everything for each directory where you call fpm build. But down the road fpm can simply build somewhere in ~/.fpm/ and cache each build and reuse them where possible.  Note also that this build directory (whether local to a project directory or in ~/.fpm/) I think might be a bit different from the fpm install command --- the build directory might have more information / metadata that the install command doesn't need to install.\nAnyway, I think we can design this so that each of us will get the functionality that we want."
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-04 15:54:37+00:00",
                    "text": "If we do eventually place built libraries in a central location like ~/.fpm/ then I would suggest that this path include the compiler and compiler version for the same reasoning as #66 due to binary incompatibility between compilers. e.g. ~/.fpm/gfortran-9.1.0/bin etc."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 17:55:03+00:00",
                    "text": "@LKedward yes, that's necessary. In fact it should be done by hashes, where a hash depends on:\n\ncompiler vendor and version\nwhether Debug or Release build\nhash of the sources for the package\nall dependencies' hashes\nhow the given package was configured --- Cargo allows some optional capabilities and we might too in the future, say if you want to build a package with or without netcdf support\n..."
                }
            ]
        },
        {
            "number": 70,
            "user": "certik",
            "date": "2020-04-30 20:08:12+00:00",
            "title": "Have a Conda backend",
            "text": "This is related to #69 but it's a separate issue. fpm should be able to create a Conda package for the project, so that it's easy to submit it to conda-forge.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 21:27:15+00:00",
                    "text": "What's required for a Conda package?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 21:44:39+00:00",
                    "text": "Here is a Conda package for my dftatom Fortran package:\nhttps://github.com/conda-forge/dftatom-feedstock/\nThe main config file:\nhttps://github.com/conda-forge/dftatom-feedstock/blob/5f4e97e3c089337b5a8e4c9be6c2c7f36dca8c6c/recipe/meta.yaml\nLinux / macOS build script:\nhttps://github.com/conda-forge/dftatom-feedstock/blob/5f4e97e3c089337b5a8e4c9be6c2c7f36dca8c6c/recipe/build.sh\nAnd Windows build script:\nhttps://github.com/conda-forge/dftatom-feedstock/blob/5f4e97e3c089337b5a8e4c9be6c2c7f36dca8c6c/recipe/bld.bat\nAll of which could be generated. The build process could simply just call fpm on all platforms."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 22:50:54+00:00",
                    "text": "That seems like it wouldn't actually require any changes to FPM."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 23:27:16+00:00",
                    "text": "One still has to generate things like \"description\", \"name\" (both of which fpm knows), and the proper template to call fpm. But yes, it should be a simple backend to fpm."
                }
            ]
        },
        {
            "number": 69,
            "user": "certik",
            "date": "2020-04-30 20:07:05+00:00",
            "title": "Have CMake and Make backends",
            "text": "Currently the Haskell based fpm is compiling things directly, just like Cargo does it. That's the best default. (The \"archived\" Rust based fpm was generating CMake.)\nHowever, until fpm is everywhere used by everybody, it would be super helpful to have a CMake and pure Make backends. That way we can move packages like stdlib or any of my own packages into using fpm, and yet not require it from the users --- they would continue using CMake or Make.\nAlso by generating the CMake / Make automatically, it will be a lot easier to maintain those in stdlib for example.\nSince fpm knows (or should know) everything about the Fortran project, it can generate 100% robust CMake and Make files, following the latest practices for CMake / Make, human readable, etc.\nI am thinking having these backends would be beneficial for many purposes, such as debugging, anyway. We should also have a Ninja backend.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 20:18:49+00:00",
                    "text": "and yet not require it from the users --- they would continue using CMake or Make.\nAlso by generating the CMake / Make automatically, it will be a lot easier to maintain those in stdlib for example.\n\nI don't understand why generate CMake of Make files. If fpm is smart enough to generate a correct CMake or Makefile for an arbitrary package, would it not be smart enough to simply build the package on its own?\nI thought that the value of enabling CMake or Make backend is when fpm is not smart enough yet to build the package on its own, but is just smart enough to detect an existing CMakeLists.txt, Makefile, or configure file, and run the appropriate commands to build it, like, cmake . or FC=gfortran make."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 20:31:08+00:00",
                    "text": "Let me see if I can explain it better.\nWe should assume that fpm is smart enough to completely build the project on its own. We are very close and we will get there soon.\nThe other assumption is that the goal has never been to call an existing CMakeLists.txt or configure script. The whole point of fpm is that users write fpm.toml and they never write CMakeLists.txt or configure by hand.\nSo with these assumptions, yes, you can just use fpm. However, it will be a while before we can just get every user using fpm. For example I don't think it would be wise to get rid of the CMake build system in stdlib and only use fpm --- maybe later, but not today. At the same time, I would love to be using fpm with stdlib as well as all my other Fortran projects now.  So to achieve it, if fpm can generate CMake, then users of my packages can keep using CMake as they do now. But I, as a developer, can just use fpm, and use fpm to generate the CMake files for my users (and commit them to git), so that I do not need to maintain the fpm build system, and a separate CMake build system by hand. And since fpm knows how to build the project on its own, it also by definition knows how to generate beautiful looking CMake files that just work (or any other build system also)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 20:48:36+00:00",
                    "text": "Okay, I understand now. The use case for this is when a developer releases a new package, they can use fpm to emit configuration files for different build systems.\nFor example, datetime-fortran started with a manual Makefile. Then Zaak wrote a CMakeLists.txt, and Michael modernized it later. Mark wrote an autotools config. Now it can be built in these different ways.\nIf I had fpm back then, I could just have done something like:\nfpm build --cmake\nfpm build --make\nfpm build --conda\n...\n\nand be done with it."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 20:55:48+00:00",
                    "text": "Yes exactly. And not just be done with it, but you can keep using fpm to keep the other build systems up-to-date. When you have a bigger project, the inter-dependencies of Fortran modules change every time you modify the use line (all the time). So you have to update manual Makefiles all the time you change this. And every time you add / remove files or move them around, you would have to update CMake also. fpm could do all that for you.\nIn fact fpm could detect that your project contains fpm-generated CMake (from some comment in it) and it can warn you every time it needs to be re-generated."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 21:25:36+00:00",
                    "text": "So, the idea here is that, not only should FPM be able to use \"non\"-FPM packages, it should also be able to generate \"non\"-FPM packages? I think this may be inviting a lot of requests for special cases. We might end up constantly chasing users who aren't willing to actually use FPM as intended.\nI'm not saying it isn't doable or worth considering. If we limit the scope to saying these other build systems must functionally produce exactly what FPM itself would do it might not be too bad, but then I don't think that actually reaches many people that we wouldn't have already convinced to switch over.\nOn the other hand it might provide a slightly smoother transition path. Make these tweaks to your current build system so FPM can use. Then get all your user's to adjust to that. Then stop maintaining that build system yourself and let FPM do it.\nI'll have to think about this for a while."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 21:37:02+00:00",
                    "text": "I made a joke a year ago, and we may actually do it.\nI share the same concerns as Brad. Mainly that this effort may not be closely aligned with FPM itself. In other words, it would be helping users to not use FPM. On the other side, if this would help many packages support multiple build systems, it would improve their portability, a long-term Fortran goal."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 21:51:19+00:00",
                    "text": "From a practical perspective, we already use both CMake and manual Makefiles for stdlib (because people have requested both) and now we also want to use fpm. I have the same problem with dftatom and Milan with datetime-fortran. I bet there are tons of other projects like that too. So instead of each of us maintaining 3 different build systems, let's just all collaborate on CMake and Makefile backend to fpm, which will produce higher quality CMake / Makefile in the end, and it will remove the burden of each of us maintaining 3 different build systems."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 22:53:34+00:00",
                    "text": "Ok, let's at least finish a beta version that just supports standard FPM projects before we start tackling this one though."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 23:27:47+00:00",
                    "text": "I agree. I only posted it here to keep it in mind."
                }
            ]
        },
        {
            "number": 68,
            "user": "certik",
            "date": "2020-04-30 19:50:53+00:00",
            "title": "How to handle non-Fortran dependencies",
            "text": "I am very confident we can make fpm very robust to work for pure Fortran packages. Just like Cargo works well for pure Rust packages or pip works great for pure Python packages.\nThe problem is with non-Fortran packages. Pip allows to hook in compiling C (and with some work) Fortran code, but it's very fragile in my experience (thus the motivation for Conda that is a binary package manager). Python doesn't have an option to avoid C++/Fortran dependencies because Python itself is slow. Rust allows to (in principle) rewrite everything in Rust. As an example, take png. The system bindings: https://crates.io/crates/libpng-sys they say are unreliable, and you should use a pure Rust implementation: https://lib.rs/crates/lodepng.\nI agree it does make things more robust to stick to pure Fortran and for many things we will do that and people will provide pure Fortran implementation of basic tasks. Python cannot do it well due to performance, but Rust and Fortran can.\nHowever, we still need a robust way of handling non-Fortran dependencies, because if there is a robust and well maintained library in another language, we should just use it instead of reimplementing everything. Take HDF5. Here is the Rust package: https://crates.io/crates/hdf5. If you look at the documentation how to build it: https://github.com/aldanor/hdf5-rust they even mention Conda (to install the HDF5 library itself on all platforms --- which in my experience is much more robust than pip). Anyway, the way it works is by this line: https://github.com/aldanor/hdf5-rust/blob/15ec644977e0bee2b77340272730b34209c3765b/Cargo.toml#L11 which causes Cargo to execute this script: https://github.com/aldanor/hdf5-rust/blob/15ec644977e0bee2b77340272730b34209c3765b/build.rs which emits flags how to link against HDF5 correctly. That way the Cargo itself doesn't need to know almost anything, it just parses the output of this file. I think we should follow the same approach in fpm. The flags in this case are emitted by: https://github.com/aldanor/hdf5-rust/blob/d4c3737772bec477739c75566a3d52d0a44f27ba/hdf5-sys/src/lib.rs#L65. I think this is when you link against hdf5 rust package in your own code. How to link against hdf5 library itself is done here I think: https://github.com/aldanor/hdf5-rust/blob/d4c3737772bec477739c75566a3d52d0a44f27ba/hdf5-sys/build.rs#L566, it's quite complicated unfortunately.\nBut it's clean from the Cargo side, it offloads the responsibility to the package itself. We can provide helpers that fpm packages can use to work with things like pkg-config, cmake packages, etc.\nIn Rust it looks like each package is on their own, so for example this HDF5 package has messy code for each platform, e.g., here: https://github.com/aldanor/hdf5-rust/blob/d4c3737772bec477739c75566a3d52d0a44f27ba/hdf5-sys/build.rs#L492, you can see they are checking brew, or Windows registry, etc.\nThe good news is that Fortran codes do not need many non-Fortran dependencies, and so doing what Rust does might work for us. What I've seen is that Fortran codes mostly need some of: Lapack, MPI, FFT, MKL, HDF5, JSON, NETCDF, HYPRE, ...\nOf which MPI and Lapack being the most important. I think fpm will have support for all Fortran compilers and I think it can have built-in support for MPI and Lapack also. One reason to special case MPI and Lapack is so that one can switch MPI implementaitons and Lapack implementations easily, and not have the Fortran packages hardcoded with a particular implementation.\nWith those out of the way, the rest can be done Cargo style, at least for now. Most other packages have just one implementation, so Fortran packages can just depend on a particular package (say Arpack, or Scalapack).",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 20:03:57+00:00",
                    "text": "I agree, this sounds quite reasonable as a first stab. Thank you for the research.\nMy personal sorted list of most used non-Fortran dependencies: MPI, HDF5, NetCDF, zlib, libpng.\nIf everybody here listed their most used dependencies, we could have an idea of top candidates which to design for and test first."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 21:06:38+00:00",
                    "text": "I definitely would like to be able to handle some non-Fortran dependencies. As it's currently designed, I think it won't be that difficult.\nThe end result of building a library in FPM is just a .a file, and all of the relevant .mod files. So, if your package specifies a build script for that, FPM will just call it. There is a small set of things that FPM would like to dictate to that script though. Those being:\n\nThe compiler to use\nThe compiler flags to use (mostly to ensure the flags are compatible with the given compiler)\nWhere to put the archive and module files\nWhere to find any of the dependencies\n\nIn this way, almost anything could be wrapped into an FPM package. Best practice would be to entirely wrap the package into a Fortran API, so consumers don't necessarily even have to know it's not Fortran, but this may not be strictly necessary in every case.\nFor the build scripts, I really like Rust's way of having the build scripts be written in Rust too. Not sure if Fortran would really be doable for that, but it would make sure building a package doesn't have additional external requirements. We could special case Makefiles and CMakeLists to use the typical environment variables I think."
                },
                {
                    "user": "pdebuyl",
                    "date": "2020-05-13 12:53:00+00:00",
                    "text": "C has a special relationship to Fortran though. Thanks to the compatibility section, it makes sense for a Fortran developer to include C code in a Fortan project. Could that be taken into account?\nMy \"pet\" usage for this is to write a PRNG in C with a Fortran wrapper module. PRNGs often use unsigned integers whose usage is possible in C.\nA fpm package could thus, in this scenario, contain Fortran and C source."
                },
                {
                    "user": "certik",
                    "date": "2020-05-13 14:18:22+00:00",
                    "text": "@everythingfunctional, @milancurcic and I discussed this point on the phone and we think so far that the best way forward is to work with Conda (or Mamba to be specific) together with their developers (@wolfv and others) to provide all non-Fortran dependencies. fpm would link with mamba and from a user perspective things would just work (users would not need to handle Conda environments explicitly).\nRegarding C support, I would suggest initially to handle them via Conda, just to keep things simple.\nWe can think if if want to later extend fpm to handle not only Fortran compilers but also C and C++ compilers."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-13 14:34:13+00:00",
                    "text": "@pdebuyl , my recommendation would be to put the C parts of your project in a separate project so that fpm can easily build the \"pure Fortran\" part of your project with ease.\nWe're planning to support make and Cmake as separate build scripts, so supporting linking with (almost) any other language and still having it be an fpm package would be possible."
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-13 16:20:01+00:00",
                    "text": "@everythingfunctional , @certik , what are the disadvantages/difficulties with natively supporting c sources in fpm? Many projects do need to include c code from time to time and this is quite normal for Fortran (even before iso_c_binding came along). I think this would be a good feature.\n(I'm not talking about whole package dependencies, just self-contained projects with mixed c/Fortran code)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-13 16:26:15+00:00",
                    "text": "I don't foresee issues with building C alongside Fortran. It may be even simpler as there are no modules to deal with."
                },
                {
                    "user": "certik",
                    "date": "2020-05-13 16:35:13+00:00",
                    "text": "Regarding C support: a full solution there is this: QuantStack/mamba#223.\nWhat we could do for fpm is not the full solution, but provide functionality for simple C source files, not full packages with a complicated build system.\nWe have to decide on a layout for C sources:\n\n\nShould the .c files be simply files in src/ folder? (I vote yes.)\n\n\nWhere should the header files be? Either in src/ or in include/.\n\n\nWhat about dependencies and their header files? (I would suggest Conda and that you can use anything from there, so fpm will create an internal environment and you can use any header file from there.)\n\n\nWhat about linking of dependencies?\n\n\nGiven that we will support C, why not C++ also? Supporting C++ would be very useful to provide Fortran wrappers: we would write a simple C wrapper that calls into a 3rd party C++ library, and call that C wrapper from Fortran, so it requires compiling of a C++ code.\n\n\nAlso one needs to link libc properly for C, and libc++ properly for C++. I think we have to do this anyway anytime we depend on a C or C++ library.\n\n\nThere will be more issues. Some of them similar to what we have to deal with anyway for Fortran sources. So I think let's keep this option open when we are designing fpm, although I still suggest to concentrate on Fortran sources first."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-13 17:24:18+00:00",
                    "text": "The low hanging fruit here seems to be handling the mixed C and Fortran source in a single project.\nJust let .c and .h sit in src/ by default, use gcc by default (like we do now with gfortran), link all object files into a static library and executable (like we do now).\nLinking to external (binary) dependencies seems orthogonal to this. Nevertheless important, but we could tackle these incrementally."
                },
                {
                    "user": "pdebuyl",
                    "date": "2020-05-13 20:47:04+00:00",
                    "text": "I had in mind the \"simple\" use case of one or a few c files that indeed \"just get compiled\" as part of the Fortran module. Making the shared C libraries available to other Fortran \"consumer code\" is probably out of scope. Anyway, thank you for the replies :-)"
                },
                {
                    "user": "certik",
                    "date": "2020-05-13 21:40:36+00:00",
                    "text": "@pdebuyl thanks for bringing it up, I think we can do that. Looking at my own code here: https://github.com/certik/hfsolver/tree/master/src, I have .f90 files, .c and .h files and also .cpp files all in the src directory. So if fpm could eventually compile all that correctly, that would go a long way. The reason I have the C and C++ files are just to interface 3rd party libraries, typically there is no way around that, as one must write some simpler wrapper that is ready to be called from Fortran using the iso_c_binding interface.\nSo I like this."
                }
            ]
        },
        {
            "number": 67,
            "user": "everythingfunctional",
            "date": "2020-04-30 03:21:47+00:00",
            "title": "Add sections to PACKAGING.md on explicit fpm.toml and tests",
            "text": "Add a couple of sections to the PACKAGING.md file and some other minor fixes.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-04-30 15:41:51+00:00",
                    "text": "I played with fpm finally, and it works well. This is how I was imagining it would work. Obviously it is still a prototype, but a usable one. Thank you @everythingfunctional for putting all the effort there! I really appreciate it.\nI think we need a mailinglist, for a general discussion. @milancurcic how about we create a fortran-lang mailinglist and simply see how it goes? We can always close it if it does not work out."
                }
            ]
        },
        {
            "number": 66,
            "user": "LKedward",
            "date": "2020-04-29 15:12:24+00:00",
            "title": "Support multiple compilers side-by-side in build",
            "text": "Currently compiled binaries are placed in build/debug/ and build/release.\nWould it be possible to make this build path dependent on compiler (and maybe architecture)?\ne.g. build/gfortran-9.2.0-x86_64_debug/\nThis reason for this being that I like to build and test my projects on multiple compilers during development; separating the binary output paths allows incremental builds using multiple compilers and allows tests on each compiler to run simultaneously and without clean and rebuild.\nThis may be considered an 'ugly' directory structure, however since fpm handles all compiler/linker paths and offers the fpm run command, this has no effect on end-user experience.\nThe workflow for using a non-default compiler could then be along the lines of:\n$> export FC=ifort\n$> fpm run\n\nor\n$> FC=ifort fpm run\n\nor\n$> fpm run --compiler=ifort",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 15:51:56+00:00",
                    "text": "Yeah, this shouldn't be too difficult. Good idea."
                }
            ]
        },
        {
            "number": 65,
            "user": "milancurcic",
            "date": "2020-04-29 14:45:54+00:00",
            "title": "How to build multiple programs?",
            "text": "Currently, FPM can build only one executable program, namely main.f90.\nHere's how Cargo does it:\n.\n\u251c\u2500\u2500 Cargo.lock\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs\n\u2502   \u251c\u2500\u2500 main.rs\n\u2502   \u2514\u2500\u2500 bin/\n\u2502       \u251c\u2500\u2500 named-executable.rs\n\u2502       \u251c\u2500\u2500 another-executable.rs\n\u2502       \u2514\u2500\u2500 multi-file-executable/\n\u2502           \u251c\u2500\u2500 main.rs\n\u2502           \u2514\u2500\u2500 some_module.rs\n\u251c\u2500\u2500 benches/\n\u2502   \u251c\u2500\u2500 large-input.rs\n\u2502   \u2514\u2500\u2500 multi-file-bench/\n\u2502       \u251c\u2500\u2500 main.rs\n\u2502       \u2514\u2500\u2500 bench_module.rs\n\u251c\u2500\u2500 examples/\n\u2502   \u251c\u2500\u2500 simple.rs\n\u2502   \u2514\u2500\u2500 multi-file-example/\n\u2502       \u251c\u2500\u2500 main.rs\n\u2502       \u2514\u2500\u2500 ex_module.rs\n\u2514\u2500\u2500 tests/\n    \u251c\u2500\u2500 some-integration-tests.rs\n    \u2514\u2500\u2500 multi-file-test/\n        \u251c\u2500\u2500 main.rs\n        \u2514\u2500\u2500 test_module.rs\n\nSo, for Fortran, the main executable could be src/main.f90, and other executables could go in src/bin.\nI like this approach, and I am not married to this particular directory structure. I also like the structure that we have now, namely app/, src/, tests/.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 15:57:27+00:00",
                    "text": "Right now, if you want multiple executables you have to specify them manually. I'm open to enabling some auto-detection of multiple executables. I'll put together an outline of what that would look like."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 16:28:46+00:00",
                    "text": "I like the Cargo layout a lot. Brad, is there a reason to use app? I would switch to src/bin to be consistent with Cargo.\n\u2026\nOn Wed, Apr 29, 2020, at 8:46 AM, Milan Curcic wrote:\n\n\n Currently, FPM can build only one executable program, namely `main.f90`.\n\n Here's how Cargo\n <https://doc.rust-lang.org/cargo/guide/project-layout.html> does it:\n\n `.\n \u251c\u2500\u2500 Cargo.lock\n \u251c\u2500\u2500 Cargo.toml\n \u251c\u2500\u2500 src/\n \u2502   \u251c\u2500\u2500 lib.rs\n \u2502   \u251c\u2500\u2500 main.rs\n \u2502   \u2514\u2500\u2500 bin/\n \u2502       \u251c\u2500\u2500 named-executable.rs\n \u2502       \u251c\u2500\u2500 another-executable.rs\n \u2502       \u2514\u2500\u2500 multi-file-executable/\n \u2502           \u251c\u2500\u2500 main.rs\n \u2502           \u2514\u2500\u2500 some_module.rs\n \u251c\u2500\u2500 benches/\n \u2502   \u251c\u2500\u2500 large-input.rs\n \u2502   \u2514\u2500\u2500 multi-file-bench/\n \u2502       \u251c\u2500\u2500 main.rs\n \u2502       \u2514\u2500\u2500 bench_module.rs\n \u251c\u2500\u2500 examples/\n \u2502   \u251c\u2500\u2500 simple.rs\n \u2502   \u2514\u2500\u2500 multi-file-example/\n \u2502       \u251c\u2500\u2500 main.rs\n \u2502       \u2514\u2500\u2500 ex_module.rs\n \u2514\u2500\u2500 tests/\n     \u251c\u2500\u2500 some-integration-tests.rs\n     \u2514\u2500\u2500 multi-file-test/\n         \u251c\u2500\u2500 main.rs\n         \u2514\u2500\u2500 test_module.rs\n `\n So, for Fortran, the main executable could be `src/main.f90`, and other\n executables could go in `src/bin`.\n\n I like this approach, and I am not married to this particular directory\n structure. I also like the structure that we have now, namely `app/`,\n `src/`, `tests/`.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#65>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWEWB2SGOZD73V6TTXTRPA4TFANCNFSM4MTZD3CQ>."
                },
                {
                    "user": "LKedward",
                    "date": "2020-04-29 16:34:11+00:00",
                    "text": "I actually much prefer app to src/bin. In my mind a bin directory is for binary files only, not source code."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 16:54:16+00:00",
                    "text": "Ok. Well, let's at least evaluate the options how to structure the layout with pros / cons. Because once we pick one, it will be hard to change.\n\u2026\nOn Wed, Apr 29, 2020, at 10:34 AM, LKedward wrote:\n\n\n I actually much prefer `app` to `src/bin`. In my mind a `bin` directory\n is for binary files only, not source code.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#65 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWCPT6UMT3RKJ6WRDJ3RPBJJFANCNFSM4MTZD3CQ>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 17:28:53+00:00",
                    "text": "The app, src separation makes it much easier to determine what should be packaged up into the library, and what is just for use in executable(s). I also makes finding the executable(s) a bit simpler for the automatically detected case. If we switch to the src/bin approach I'll need to special case out of searching that directory when building the library."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 17:59:54+00:00",
                    "text": "I see, good point. Are we still doing src/main.f90 to mean an executable? If so, then you have to special case this anyway."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-29 18:13:31+00:00",
                    "text": "I think we should aim to minimize special cases in the UI, and implement accordingly. A good test for this is asking what design leads to the simplest user guide.\nFor example, if everything in src is considered a library component except src/main.f90 and src/bin/*.f90, then these are special cases that require additional clauses in the documentation.\nOn the other hand, app for programs and src for library is simplest to explain to a user, and is currently my favorite solution.\nAn even simpler UI than this (to explain to a user) is to have program files be programs, and module files be modules, regardless of where they are in the tree. However this complicates implementation because now fpm needs to parse the sources. A downside is that now there may not be clear separation between programs and module files if the user is just looking at the source tree. However if you have app and src, it's clear.\nWe should study Rust+Cargo model in detail, but we shouldn't assume that it's the optimal solution for us. This could be because of Rust's own history of the project, or because Rust and Fortran are different languages and have different cultures.\nI agree with @LKedward about app vs bin."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 18:27:07+00:00",
                    "text": "Good points. Note that fpm has to parse the sources anyway to determine module dependencies and to enforce that each module name is named appropriately.\nSo looks like the most natural solution so far is:\n\nsrc contains module files (or loose procedures / function --- we should not encourage it, but some existing projects do that and I think we can incorporate this without harm). Everything in src gets built into a library.\napp, contains programs. Perhaps app/main.f90 could be the main program (by default executed by fpm run).\ntests contains tests\nbench contains benchmarks (we can do this one later perhaps --- although most of my projects contain some kind of benchmarks which are distinct from apps and distinct from tests)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 21:41:54+00:00",
                    "text": "I see, good point. Are we still doing src/main.f90 to mean an executable? If so, then you have to special case this anyway.\n\nNo, I didn't implement src/main.f90 to be an executable. If it sees that it will expect it to be a module named main."
                }
            ]
        },
        {
            "number": 64,
            "user": "milancurcic",
            "date": "2020-04-29 14:38:17+00:00",
            "title": "fpm run and fpm test should emit a message if no action is taken",
            "text": "Currently, if you issue fpm run in a library project without executable program, it does nothing.\nIt'd be more user friendly if we emitted a message to stderr, something like:\nfpm: This package has no executable programs.\n\nor similar.\nLikewise for fpm test. If there are no test, we should say something like:\nfpm: This package has no tests.\n\nWhat do you think?",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 14:39:43+00:00",
                    "text": "Not a bad idea. Shouldn't be too difficult to implement."
                }
            ]
        },
        {
            "number": 63,
            "user": "milancurcic",
            "date": "2020-04-29 14:34:01+00:00",
            "title": "Don't require compiler field in fpm.toml",
            "text": "Following up on the discussion in #60, let's remove the requirement for the compiler setting in the package-specific fpm.toml.\nFor now, FPM should default to gfortran, and we can put a note in the README or the packaging guide that gfortran is currently the only compiler supported. We can relax this at a later time. The compiler setting can still remain in the toml parser as optional--perhaps we will want to allow package-specific choice of compiler.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 14:41:04+00:00",
                    "text": "That's reasonable for now. I'll make that change on my PR"
                }
            ]
        },
        {
            "number": 62,
            "user": "everythingfunctional",
            "date": "2020-04-29 02:55:30+00:00",
            "title": "Handling Dependencies",
            "text": "My basic outline of how to do this is the following recursive algorithm:\n\nfor each listed dependency, download/check it out\nGo into the dependency's fpm.toml file and for each of it's dependencies\na. if it's already been downloaded, check that it's version is compatible, otherwise recursively repeat this process\nCollect each of the dependencies dependencies,\nReturn the tree of dependencies\nBuild each of the dependencies, recursively building each of it's dependencies first",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 02:58:57+00:00",
                    "text": "I should be able to implement this soon. I'll use a similar toml specification style as Rust's cargo. I got sidetracked implementing the ability to parse that properly for the toml parser we're using.\nWhich brings up a question. Do we specify the specific git version of that library as one of our dependencies, or do we include the functions I implemented directly in our source? For either, at some point we'll be able to remove it and go back to using the library as normal."
                },
                {
                    "user": "LKedward",
                    "date": "2020-04-29 08:17:58+00:00",
                    "text": "Thanks @everythingfunctional, this will be great to get working! I have a few questions:\n\nAt this stage are dependencies simply specified directly as git repository urls (#33 decentralized package management)?\nAre you using git tags to track specific versions in git repositories?\nHow are dependency versions specified in fpm.toml? (cargo supports several version operators)\nAre you adopting some form of semantic versioning rules to resolve version compatibility?\n\nAlso: surely you can only resolve compatible dependency versions after the entire dependency tree has been constructed?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 14:30:29+00:00",
                    "text": "For now, we'll just support git repository urls, since we don't have a centralized repo yet.\nJust like cargo does, we'll support tags, commits, or branches being specified for a git dependency.\nI'm planning to implement version specifications exactly like cargo does. That's a bit longer term goal though.\nYes, we'll adopt semantic versioning rules. Long term, it may even be possible to enforce those rules in a centralized repository.\nIn the short term, we won't \"resolve\" dependency versions. It will just check if the version already downloaded is compatible with the package's requirements. If not we'll just throw an error. You can then \"resolve\" the conflict by specifying a version that works for all the dependencies in your package. I don't know of any package manager that has really and truly solved the version compatibility search problem. Many have just reasonable approximations or workarounds."
                }
            ]
        },
        {
            "number": 61,
            "user": "milancurcic",
            "date": "2020-04-28 20:52:11+00:00",
            "title": "add license",
            "text": "FPM needs a license.\nMIT seems a no-brainer here, but need permission from contributors.",
            "comments": []
        },
        {
            "number": 60,
            "user": "milancurcic",
            "date": "2020-04-28 20:47:08+00:00",
            "title": "Package layout guide",
            "text": "First stab at describing package layout and examples.\nI took the user guide approach rather than a specification document because:\n\nIt's impossible to separate package layout specification (output of tree) and fpm.toml specification; they are interdependent;\nIt's impossible to predict the exact specification that we'll need; in other words, we need to work up to it;\nBy writing this out as a user guide, I had to learn it enough to teach it. This process illustrates what's missing and what's working or not working. We should take it step by step from there.\nWe want users to try to adapt their package to FPM and open issues with what doesn't work or is unclear.\n\nPlease read it and let me know any suggestions, or edit the document directly.\nYou'll see that I asked one question and proposed two issue candidates in quotation blocks (>). We should remove them and open issues before merging this.\nEverything covered in the guide works with current master of FPM, except a few details about fpm.toml settings that aren't implemented.\nI also need to say, even at this early and raw stage it's pleasure using FPM. Doing something like this with Fortran code is already pushing the boundary. So, great work @everythingfunctional and @certik.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-04-28 21:06:59+00:00",
                    "text": "Thanks @milancurcic for writing a tutorial for this. Very helpful. It looks great overall and I don't have any issues with it, except one big one: I strongly feel we should not be encoding compiler options into fpm.toml and so we should not be encouraging users to do so. In the same way, we should not be encoding standard layout into fpm.toml either. FPM should allow both as an option, but by default it would do the right thing.\nSo in particular, none of this should be there:\ncompiler = \"gfortran\"\ndevel-options = [\"-g\", \"-Wall\", \"-Wextra\", \"-pedantic\"]\nrelease-options = [\"-O3\"]\n\n[executables.executable-name]\nmain = \"main.f90\"\nsource-dirs = \"app\"\nlinker-options = [\"-O3\"]\n\nThis should be all inferred automatically. Exactly as Cargo works.\nI think fpm might not be able to do it yet. That is fine, but in that case I would like to see very clearly stated that this is temporary and show how the fpm.toml will look like once we implement this."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-28 21:31:39+00:00",
                    "text": "@certik I agree. What I think makes most sense is:\n\nfpm has default behavior baked in\n(optional) compiler can be changed on fpm level (not the package level)\n(optional) some packages may need to override default compiler flags, but I assume this is minority of packages.\n\nIt turns out, right now fpm doesn't require any of this except compiler. So even for the last example, this is a valid fpm.toml:\nname = \"math_constants\"\nversion = \"0.1.0\"\nlicense = \"MIT\"\nauthor = \"Jane Programmer\"\nmaintainer = \"jane@example.com\"\ncopyright = \"2020 Jane Programmer\"\ndependencies = []\ncompiler = \"gfortran\"\nSo I can go right ahead and remove the other settings from examples. That will also make the tutorial simpler.\nAs for the compiler setting, it seems like it would be straighforward for @everythingfunctional to hardcode it for now. I think that's a reasonable temporary solution."
                },
                {
                    "user": "certik",
                    "date": "2020-04-28 21:56:15+00:00",
                    "text": "fpm can optionally allow setting the compiler + options both at the package level (fpm.toml) as well as the fpm level (command line options / configure file such as ~/.fpmconfig).\nIdeally most packages will not specify either, just use the default as in your tutorial (I agree we should remove the gfortran that is currently still hardwired in fpm.toml even though clearly those examples would compile with any Fortran compiler). That way getting all packages working with a new compiler (say Flang or LFortran later on) would be trivial --- just add support for those compilers into fpm.\nOnly packages that truly require some special handling in compilers should do so --- and even then we should try to see what special handling they require. I've seen that some old f77 code requires the -std=legacy gfortran option. In that case I would suggest to not make them gfortran specific, but rather introduce a legacy=true fpm option (or in this case std=f77, std=f2018, ...), that would (in principle) work with any Fortran compiler and fpm would figure out what options must be set for each compiler."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 02:16:23+00:00",
                    "text": "This looks really good. I haven't read all the way through it yet, but I did notice a few inconsistencies with how I actually finished implementing all the toml options. I suggest we go ahead and merge this though, and then I'll fix any inconsistencies on my branch before we merge it. I should be able to do that within the next few days.\nI'll note that while in my implementation the compiler flags are hard coded, the compiler actually isn't. I suspect in the short term we'll pick different hard coded flags based on the compiler specified, and long term we'll come up with a compiler agnostic way of specifying special flags needed for a given project."
                }
            ]
        },
        {
            "number": 59,
            "user": "milancurcic",
            "date": "2020-04-26 18:46:49+00:00",
            "title": "remove -Werror gfortran flag",
            "text": "Fixes #56",
            "comments": []
        },
        {
            "number": 58,
            "user": "milancurcic",
            "date": "2020-04-26 18:44:47+00:00",
            "title": "Update readme and executable name",
            "text": "This PR:\n\nUpdates install instructions in the README and adds instructions on how to use fpm.\nRenames FPM executable from fpm-exe to fpm.\n\nFixes #55",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-04-28 21:56:01+00:00",
                    "text": "@certik Does this look good? It's a simple PR."
                }
            ]
        },
        {
            "number": 57,
            "user": "milancurcic",
            "date": "2020-04-26 18:18:15+00:00",
            "title": "fpm assumes .mod has the same name as the source file",
            "text": "If I have a source file datetime.f90 that contains a module called datetime_module, then gfortran (and all other compilers I believe) output datetime_module.mod. However, fpm expects datetime.mod and can't find it.\nI believe the assumption about .mod filename comes from somewhere around here, however I don't have a solution right now.\nI think the safe assumption is that the .mod file will have the module name, for fpm will need to scan the source file to get this info.\nFurther, a source file can have multiple modules defined, and for each the compiler will emit one .mod file.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 21:06:21+00:00",
                    "text": "That assumption actually comes from here.\nThe reasoning is that we want the file name to match the module name, and the module name to include the path components of the file name. This was a basic structure to help with organizing modules that @certik and I came up with.\nThere are ways to just inspect the source files and figure out the module names and dependencies more flexibly, but for our initial implementation we wanted to keep things as simple as possible and try and encourage a common organizational convention.\nObviously this is something that should be added to the README. @certik , do you think you'll have time to write up our standard conventions in the README any time soon?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 21:27:04+00:00",
                    "text": "Specifically for datetime-fortran, that's fine. I'm happy to rename the source file so it can build with fpm.\nI also support encouraging the practice one module per source file, with file name matching the module.\nHowever, I think this may be quite limiting if fpm is to build existing packages. I don't know, but it's possible that there are many that have multiple modules per source file.\nThis made me think now: why would there be an expectation for a specific .mod file to be present? AFAIK, the compiler cares only about the include path and that the modules are there. It knows how to find the file in the include directory. So, this requirement by fpm seems artificial to me. Could it be removed so that fpm only checks for .o files? I think it's safe to assume that if .o file is created, that the .mod files have been created as well."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 21:28:26+00:00",
                    "text": "However, I think this may be quite limiting if fpm is to build existing packages. I don't know, but it's possible that there are many that have multiple modules per source file.\n\nRelated to this, I think more problematic is that this requirement would prevent fpm from building correct and modern Fortran code."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-27 04:22:28+00:00",
                    "text": "It's more about rebuilds. If you change a module and rebuild, then if the .mod file changes, you need to rebuild everything that depends on it."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 05:12:55+00:00",
                    "text": "Yes, the default layout restricts what can be done, and you want that. It's not meant as a replacement for cmake, which allows you to do anything, but you pay for it by maintaining a complex buildsystem. We want to rather create a convention, that would allow fpm to figure out everything by itself.\n\nFor existing packages we either have to adapt them, or we need to tell fpm extra information where things are.\n\u2026\nOn Sun, Apr 26, 2020, at 10:22 PM, Brad Richardson wrote:\n\n\n It's more about rebuilds. If you change a module and rebuild, then if\n the .mod file changes, you need to rebuild everything that depends on\n it.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#57 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWBXBCUBJJZTLO54K4LROUCBBANCNFSM4MRK6V2A>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 12:27:17+00:00",
                    "text": "Okay, sounds good. We can revisit if it shows to be an issue, I don't think it is right now.\nYes, it'd be good to discuss and write out requirements for packages. I don't remember seeing this specific one anywhere."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 15:58:24+00:00",
                    "text": "@milancurcic see #39."
                }
            ]
        },
        {
            "number": 56,
            "user": "milancurcic",
            "date": "2020-04-26 17:59:16+00:00",
            "title": "Correct code fails to build due to hardcoded -Werror",
            "text": "fpm is currently making gfortran fail on warning by hardcoding -Werror. Removing -Werror from fpm.toml doesn't change this behavior (I understand specifying flags via fpm.toml may not be implemented yet.\nHowever, in the meantime, we shouldn't use -Werror because it's making correct code to fail. For example:\n[milan@gary test_project_error]$ cat src/mylib.f90 \nreal :: a, b\na = 2.\nb = 2.\nprint *, a == b\nend\n[milan@gary test_project_error]$ cat fpm.toml \nname = \"package-name\"\nversion = \"0.1.0\"\nlicense = \"BSD3\"\nauthor = \"Author name here\"\nmaintainer = \"example@example.com\"\ncopyright = \"2020 Author name here\"\ndependencies = []\ncompiler = \"gfortran\"\ndevel-options = [\"-g\", \"-Wall\", \"-Wextra\", \"-pedantic\"]\nrelease-options = [\"-O3\"]\n\n[library]\nsource-dirs = \"src\"\n[milan@gary test_project_error]$ fpm build\n# gfortran (for build/debug/library/mylib.o build/debug/library/mylib.mod)\nsrc/mylib.f90:4:8:\n\n print *, a == b\n        1\nError: Equality comparison for REAL(4) at (1) [-Werror=compare-reals]\nf951: all warnings being treated as errors\nfpm-exe: Error when running Shake build system:\n  at want, called at src/Build.hs:188:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/package-name.a\n  at need, called at src/Build.hs:186:13 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/mylib.o\n  at &%>, called at src/Build.hs:166:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/mylib.o build/debug/library/mylib.mod\n  at cmd, called at src/Build.hs:179:19 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Raised the exception:\nDevelopment.Shake.cmd, system command failed\nCommand line: gfortran -c -Jbuild/debug/library -Wall -Wextra -Wimplicit-interface -Werror -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -o build/debug/library/mylib.o src/mylib.f90\nExit code: 1\nStderr:\nsrc/mylib.f90:4:8:\n\n print *, a == b\n        1\nError: Equality comparison for REAL(4) at (1) [-Werror=compare-reals]\nf951: all warnings being treated as errors\n\nWhat do you think?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-04-26 18:15:42+00:00",
                    "text": "I think Werror is not your friend and should not be used here; especially here where we cannot guarantee a specific compiler version.\nLatest gfortran actually produces spurious warnings for certain derived-type allocations so Werror would completely prevent you from producing a debug build.\n#50"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 21:15:52+00:00",
                    "text": "As I mentioned on the PR, I'm fine with removing the -Werror flag from the default list. But in this instance I will point out that comparison of reals really is a bad idea. Floating point math means that equality will almost surely never be true. For example, I'm pretty sure (1.0 / 3.0) == ((1.0 / 9.0) * 3.0) is false, when you really would expect it to be true."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 21:35:26+00:00",
                    "text": "In most cases, yes, and that's why there should be a warning for it. :)"
                }
            ]
        },
        {
            "number": 55,
            "user": "milancurcic",
            "date": "2020-04-25 17:52:58+00:00",
            "title": "stack build does not add fpm executable to path",
            "text": "First time running stack. On running stack build, it looks like the fpm executable is not installed in any working path. I expected it to be installed either somewhere under stack like pip does, or locally and then added to my path.\nFor example, I'm working in /home/milan/Work/fortran/fpm, fpm-exe is installed here: /home/milan/Work/fortran/fpm/.stack-work/install/x86_64-linux-tinfo6/68e6a00e61079ec9146947ae047a1ce619d26ace12c1e4cd5fd58ceb496743b0/8.6.5/bin\nso I had to add this to my PATH.\nIs this expected behavior? If not, is this an issue with stack or with fpm?\nfpm-exe should be called just fpm.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 17:20:18+00:00",
                    "text": "stack build is not supposed to install the executable. I'll have to try it, but I believe stack install will do what you are after. I think it typically will install it to $HOME/.local/bin."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 18:58:34+00:00",
                    "text": "Thanks, I tested stack install and it works."
                }
            ]
        },
        {
            "number": 54,
            "user": "everythingfunctional",
            "date": "2020-04-14 00:37:36+00:00",
            "title": "Additional testing",
            "text": "Set up and test some example projects",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-22 02:46:11+00:00",
                    "text": "I think this is now sufficient for any project, with no dependencies, on any platform. But please feel free to put it through the ringer and let me know if you find anything."
                },
                {
                    "user": "certik",
                    "date": "2020-04-22 03:54:13+00:00",
                    "text": "Thanks @everythingfunctional. I'll test it out soon. I was really busy with other things lately."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 19:00:58+00:00",
                    "text": "I just noticed this didn't make it to master yet. I will play with it. So far I worked only with current master."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 23:29:17+00:00",
                    "text": "@certik , do you want a chance to test it out, or should I go ahead and merge this?"
                }
            ]
        },
        {
            "number": 53,
            "user": "everythingfunctional",
            "date": "2020-04-11 22:45:31+00:00",
            "title": "Finish commands",
            "text": "Finish the required functionality for a project with no dependencies.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-12 05:15:52+00:00",
                    "text": "Yeah, we should test a variety of setups, with default settings, specified default settings, and non-default settings. I guess my next steps should be to come up those examples."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-13 02:47:40+00:00",
                    "text": "@milancurcic , absolutely."
                },
                {
                    "user": "certik",
                    "date": "2020-04-13 17:40:38+00:00",
                    "text": "Thanks @everythingfunctional for working on this. It's quite difficult for me to contribute to the Haskell code base, as I am still learning it, but I'll be able to greatly help with the test cases --- if you provide some initial tests, I'll submit PRs with more tests."
                }
            ]
        },
        {
            "number": 52,
            "user": "everythingfunctional",
            "date": "2020-04-11 21:46:12+00:00",
            "title": "Finish simple project settings",
            "text": "This finishes up all the necessary settings for a basic simple project",
            "comments": []
        },
        {
            "number": 51,
            "user": "everythingfunctional",
            "date": "2020-03-31 20:50:29+00:00",
            "title": "Two stage settings",
            "text": "This splits the settings for FPM into a two stage process and starts to make use of that for default behavior",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-31 20:53:18+00:00",
                    "text": "The architecture is starting to come together and look reasonable so far. No major changes should be needed from this point to support all 3 commands for a project with no dependencies. I think that will be my next step after this."
                },
                {
                    "user": "certik",
                    "date": "2020-04-04 16:19:42+00:00",
                    "text": "Yes, our goal should be that fpm packages work with all compilers by default. My experience is with larger Fortran codes that they typically work with a few particular compilers but not all, e.g., one of our codes works with Intel and NAG, but not gfortran. I don't know if it makes sense to allow fpm packages to restrict which compilers it works with. But for now I would simply allow all.\n\u2026\nOn Sat, Apr 4, 2020, at 9:33 AM, Milan Curcic wrote:\n\n\n ***@***.**** approved this pull request.\n\n \ud83d\udc4d\n\n Should the compiler choice (e.g. gfortran) be set in fpm.toml? It seems\n to me more appropriate to be a local fpm setting and not a package\n setting. It's okay here for now, just a note for later.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#51 (review)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWHLSETPQZ5T3WR6ILLRK5HNLANCNFSM4LX72EBA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-04 17:17:08+00:00",
                    "text": "My thought is that the fpm.toml doesn't specify which compilers a package works with, but which compiler is used by default when building that package on its own. When building a package as a dependency for another project I don't expect any settings to be taken from the fpm.toml file except where to find the source files, and what other dependencies are needed. Compiler, flags, any other relevant settings would be set by the parent project and be in effect for building all dependencies."
                }
            ]
        },
        {
            "number": 50,
            "user": "everythingfunctional",
            "date": "2020-03-30 15:20:37+00:00",
            "title": "Compiler flags",
            "text": "How should we organize/specify compiler flags?\nShould we only have two sets of compiler flags? devel-options and release-options, and they are used to build all dependencies and executables?\nAlso, should we come up with our own keywords for specifying the compiler options, and have a look up table to determine the correct flag for each compiler?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-30 16:29:04+00:00",
                    "text": "We will have to iterate on this, I don't know all the details either yet. Here are some guiding principles:\n\nWe should have Debug and Release builds. (I would call it Debug, not Devel.)\nPerhaps also ReleaseCheck (that would enable all optimizations, but keep all runtime checks; it could be named differently, perhaps ReleaseSafe, or something).\n\nThe Debug build should enable all runtime and compile time checks / warnings that a given compiler allows. The Release build should make the fastest build for the given architecture. For ifort I think that's the default (i.e. no options). For gfortran that's -O3 -march=native -ffast-math -funroll-loops (the later gfortran versions also have -Ofast which does a lot of these and a few more --- so we should look into it and probably use it).\nSo as a start, I would start with Debug and Release. Then as we go, we can keep refining it.\nWe can take the initial options for gfortran / Intel from here:\nhttps://www.fortran90.org/src/faq.html#what-compiler-options-should-i-use-for-development\nhttps://www.fortran90.org/src/faq.html#what-compiler-options-should-i-use-for-production-run"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-30 19:07:49+00:00",
                    "text": "Those are good suggestions for defaults. But I'm more talking about what we want to allow users to specify.\nShould we only allow users to specify a single set of compiler flags for each of debug and release modes? Or should there be some more granularity available? Different flags for executables vs libraries?\nAlso, when a user specifies compiler flags manually, should they specify the flags directly (i.e. \"-funroll-loops\") or with a more generic option that looks up the specific flag for the given compiler?"
                },
                {
                    "user": "certik",
                    "date": "2020-03-30 21:22:45+00:00",
                    "text": "Ah I see. I would definitely allow to specify any compiler flag to any file and any executable / library. That way it should be possible to build any project out there. It's just that we want to discourage users doing that obviously, but we should allow that.\nRegarding \"generic options\" like \"unroll loops\" for \"-funroll-loops`, I would not do that, because I think it will be very hard to find such options for every compiler. Initially the only generic options that I would allow are Debug / Release / ReleaseSafe. Later on, we can perhaps add more, if users request them.\nSo for example, the user can select Debug mode that would be applied to every file, except those that the user specifically sets manually."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-30 21:49:28+00:00",
                    "text": "Ok, that's definitely going to have to take some thinking about how to design on both the fpm.toml side, and the actual build process side."
                },
                {
                    "user": "certik",
                    "date": "2020-03-30 21:54:46+00:00",
                    "text": "We should not over design this. Right now we are just writing a prototype, to help us figure out the requirements, because what you are asking for are the requirements which we do not know yet, until we gain more experience using fpm with actual Fortran codebases."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-31 13:52:31+00:00",
                    "text": "You're right. I'm just going to leave out the options to specify compiler flags for now. Until we have time to design it properly."
                }
            ]
        },
        {
            "number": 49,
            "user": "everythingfunctional",
            "date": "2020-03-28 18:35:57+00:00",
            "title": "TOML to Settings Architecture",
            "text": "I'm creating this as mostly a reference for how I think we should proceed with having sane defaults to allow minimal fpm.toml files. Right now I'm just reading the toml contents directly into the data structure for the settings for building the project. What I think will make more sense is to have two different data structures. One for reading the settings from the fpm.toml file, and a slightly different one for the settings for the project passed to the rest of the process. This will allow a step for interrogating the file system for some of the defaults based on the presence/absence of information in the fpm.toml file.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:23:55+00:00",
                    "text": "Closing this since it's been implemented this way."
                }
            ]
        },
        {
            "number": 48,
            "user": "everythingfunctional",
            "date": "2020-03-28 18:30:02+00:00",
            "title": "Simplify example project",
            "text": "This simplifies the example project and sets things up to begin building according to the settings read from fpm.toml",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-30 21:10:03+00:00",
                    "text": "Thanks!"
                }
            ]
        },
        {
            "number": 47,
            "user": "everythingfunctional",
            "date": "2020-03-24 21:12:17+00:00",
            "title": "Read fpm toml",
            "text": "Start reading the settings for a package from fpm.toml",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-24 21:37:14+00:00",
                    "text": "I've got it reading the first setting from an fpm.toml file. Take a look and let me know what you guys think."
                },
                {
                    "user": "certik",
                    "date": "2020-03-24 22:17:35+00:00",
                    "text": "I think this looks good.\nThis implements explicit layout, which we should support also. Based on our past discussion, by default we would encourage users to use the implicit layout, so they just need to put a file in the bin directory, and fpm will automatically build the binary out of it, just like Cargo."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-25 13:36:18+00:00",
                    "text": "I think this looks good.\nThis implements explicit layout, which we should support also. Based on our past discussion, by default we would encourage users to use the implicit layout, so they just need to put a file in the bin directory, and fpm will automatically build the binary out of it, just like Cargo.\n\nImplicit layout will be a bit trickier to implement I think. The default would be only one executable, with main having the default expected name (probably main.f90).\nAll doable. I think we should start with explicit, make sure that works, then come up with lots of example projects, leaving various things out to allow for defaults."
                },
                {
                    "user": "certik",
                    "date": "2020-03-25 16:14:15+00:00",
                    "text": "Here is our last iteration that we did at the Committee meeting in Vegas:\n#39 (comment)\nAnd to have more executables in the app directory, you just add more subdirectories just like Cargo does it I think."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-03-25 16:39:30+00:00",
                    "text": "I think the purpose of going for an implicit, minimal, sane default is that it can be implemented most quickly. You can then assess what's most needed to generalize next. I prefer this approach to development and we use it at Cloudrun.\nOtherwise, we have to make a lot of assumptions on what are all the options and edge cases that will be desired, and we'd spend a lot of time doing that."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-25 23:03:06+00:00",
                    "text": "With the toml parser I'm using, it's actually easiest to define the data structure that holds all the necessary settings, and require they be present in the toml file. Then we can figure out how to make that setting optional (have a default). Yes we should start with the simplest possible project and the simplest settings, but it actually is easier to make them required first."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-25 23:05:47+00:00",
                    "text": "I'm going to merge this in and then take a stab at simplifying the example project and it's toml file to the bare minimum."
                }
            ]
        },
        {
            "number": 46,
            "user": "everythingfunctional",
            "date": "2020-03-13 02:25:57+00:00",
            "title": "Create first draft of an example fpm.yaml file",
            "text": "This is a first shot at what an fpm.yaml file might look like.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-13 03:38:04+00:00",
                    "text": "Thanks for trying to figure out what to put in.\nMy view is to do exactly what Rust / Cargo does. In Cargo, you can set many of these options, but by default, you do not, and you follow the layout. And you then tell cargo to build in Release or Debug modes, and Cargo chooses the default options.\nIn our case, I was thinking of following exactly the same approach. That is, fpm will support all Fortran compilers. Which means, the compiler specific options should not be set in fpm.toml, because those would be specific to a compiler, so would not work with another compiler.\nSo I would suggest to simplify your example as follows:\nname:                package-name\nversion:             0.1.0\nlicense:             BSD3\nauthor:              \"Author name here\"\nmaintainer:          \"example@example.com\"\ncopyright:           \"2020 Author name here\"\n\ndependencies: \n- stdlib\n\ntests-dependencies:\n    - vegetables 1.0  # I think in Cargo this means >= 1.0 and < 2.0\nFinally, I would follow Cargo's naming conventions.\nI am going to post a TOML example."
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 03:44:41+00:00",
                    "text": "Here is the TOML equivalent:\n[package]\nname = \"package-name\"\nversion = \"0.1.0\"\nlicense = \"BSD3\"\nauthors = [\"Author name here <example@example.com>\"]\nedition = \"2018\"\n\n[dependencies]\nstdlib = \"0.2.3\"\n\n[dev-dependencies]\nvegetables = \"1.0\""
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 04:00:30+00:00",
                    "text": "For comparison, a literal translation of the YAML to TOML is:\nname = \"package-name\"\nversion = \"0.1.0\"\nlicense = \"BSD3\"\nauthor = \"Author name here\"\nmaintainer = \"example@example.com\"\ncopyright = \"2020 Author name here\"\ndependencies = [\"../std-lib.tar.gz\"]\ncompiler = \"gfortran\"\ndevel-options = [\"-g\", \"-Wall\", \"-Wextra\", \"-Werror\", \"-pedantic\"]\nrelease-options = [\"-O3\"]\n\n[library]\nsource-dirs = \"src\"\n\n[executables.executable-name]\nmain = \"Main.f90\"\nsource-dirs = \"app\"\nlinker-options = [\"-O3\"]\ndependencies = [\"iso_varying_string\"]\n\n[tests.test-name]\nmain = \"Spec.f90\"\nsource-dirs = \"test\"\nlinker-options = [\"-Og\"]\ndependencies = [\"vegetables >= 1.0 && < 2.0\"]\n(But as I said, I think we should simplify some of the sections and follow Rust's naming scheme.)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-11 17:59:46+00:00",
                    "text": "Closing, since we're going with toml"
                }
            ]
        },
        {
            "number": 45,
            "user": "everythingfunctional",
            "date": "2020-03-12 03:08:54+00:00",
            "title": "Package File Spec",
            "text": "We need a specification, or at least a start of one, for what should go into the package file and how it should be organized.\nI'd suggest we start by answering the question \"What does fpm need to know about a package in order to be able to build it?\" in as much detail as possible and then trying to organize it logically.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:24:59+00:00",
                    "text": "I think we've settled this now?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 05:25:42+00:00",
                    "text": "Yes.\n\u2026\nOn Wed, Apr 29, 2020, at 9:25 PM, Brad Richardson wrote:\n\n\n I think we've settled this now?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#45 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWBSCLSYDG6OBIOZH73RPDVRPANCNFSM4LGDENXA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 14:06:16+00:00",
                    "text": "Ok, closing."
                }
            ]
        },
        {
            "number": 44,
            "user": "everythingfunctional",
            "date": "2020-03-12 03:05:20+00:00",
            "title": "toml or yaml or something else",
            "text": "Are we sold on using toml as the file format for a package manifest/configuration file?\nI see that Rust uses toml, but many other package mangers use others. Haskell's Stack uses yaml, and I think I've seen others use that. I think I've also seen json, and maybe even xml.\nA new project Cargo.toml looks like:\n[package]\nname = \"rusttest\"\nversion = \"0.1.0\"\nauthors = [\"Brad Richardson <brichardson@structint.com>\"]\nedition = \"2018\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n\nand a new project package.yaml (for Haskell) looks like:\nname:                haskelltest\nversion:             0.1.0.0\ngithub:              \"githubuser/haskelltest\"\nlicense:             BSD3\nauthor:              \"Author name here\"\nmaintainer:          \"example@example.com\"\ncopyright:           \"2020 Author name here\"\n\nextra-source-files:\n- README.md\n- ChangeLog.md\n\n# Metadata used when publishing your package\n# synopsis:            Short description of your package\n# category:            Web\n\n# To avoid duplicated efforts in documentation and dealing with the\n# complications of embedding Haddock markup inside cabal files, it is\n# common to point users to the README.md file.\ndescription:         Please see the README on GitHub at <https://github.com/githubuser/haskelltest#readme>\n\ndependencies:\n- base >= 4.7 && < 5\n\nlibrary:\n  source-dirs: src\n\nexecutables:\n  haskelltest-exe:\n    main:                Main.hs\n    source-dirs:         app\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - haskelltest\n\ntests:\n  haskelltest-test:\n    main:                Spec.hs\n    source-dirs:         test\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - haskelltest\n\nI'm not strongly opposed to toml, but it's the one I'm least familiar with. My gut tells me we should go with yaml. I would not suggest json or xml though, too much syntax/line noise.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-03-13 00:35:16+00:00",
                    "text": "Both toml and yaml look good and have sufficient capability. Yaml is personally slightly prettier to me.\nWhich has a more mature parser in Haskell? Let's go with that one.\nI recommend against json for configuration files (even though I use it a lot) because it doesn't allow comments. This would make it harder to work with them in development and testing when you want to quickly try out different values. It's also a bit more noisy (verbose) than either toml or yaml.\nxml burns my eyes."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-13 01:44:44+00:00",
                    "text": "There are parsers for both that seem pretty mature. I just think yaml is more naturally represented as a simple/common data structure, so it is easier to work with once it's parsed.\n@certik , do you have a vote?"
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 01:50:06+00:00",
                    "text": "I vote for toml, I think it's more readable, that's what Rust and Python uses and I would follow exactly the Rust model for everything unless we have a good reason not to. Fortran is close to Python and Rust in most respects than to Haskell.\n\u2026\nOn Thu, Mar 12, 2020, at 7:44 PM, Brad Richardson wrote:\n\n\n There are parsers for both that seem pretty mature. I just think yaml\n is more naturally represented as a simple/common data structure, so it\n is easier to work with once it's parsed.\n\n @certik <https://github.com/certik> , do you have a vote?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#44 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWCKGWTCASXNGTPTJATRHGFZRANCNFSM4LGDB7AA>."
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 02:03:10+00:00",
                    "text": "Here are good pros and cons:\n\nhttps://www.reddit.com/r/rust/comments/7izxrg/toml_or_yaml_for_config/\n\nOne big downside of yaml is that it is very complicated. TOML is very simple for flat configuration files, and Cargo shows that flat is enough. And we should strive for flat.\n\nI agree that we should not use JSON or XML.\n\u2026\nOn Thu, Mar 12, 2020, at 7:49 PM, Ond\u0159ej \u010cert\u00edk wrote:\n I vote for toml, I think it's more readable, that's what Rust and\n Python uses and I would follow exactly the Rust model for everything\n unless we have a good reason not to. Fortran is close to Python and\n Rust in most respects than to Haskell.\n\n On Thu, Mar 12, 2020, at 7:44 PM, Brad Richardson wrote:\n >\n >\n > There are parsers for both that seem pretty mature. I just think yaml\n > is more naturally represented as a simple/common data structure, so it\n > is easier to work with once it's parsed.\n >\n > @certik <https://github.com/certik> , do you have a vote?\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <#44 (comment)>,\n > or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWCKGWTCASXNGTPTJATRHGFZRANCNFSM4LGDB7AA>.\n >"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-13 03:10:43+00:00",
                    "text": "@certik , that sounds reasonable. I put together an example of what an fpm.yaml file would look like (#46). Could you try converting that to toml so we can see what that would look like?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-03-13 04:08:58+00:00",
                    "text": "I am now in favor of toml as well. I like the idea of following the Rust packaging model."
                },
                {
                    "user": "certik",
                    "date": "2020-03-23 16:29:17+00:00",
                    "text": "@everythingfunctional see my comments at #46: #46 (comment) how it would look like in YAML and TOML. Let me know your thoughts."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-23 16:56:09+00:00",
                    "text": "I think the TOML looks fine. I'll start trying to put together the logic to pull in the dependencies, and compile them in the right order based on the fpm.toml file."
                },
                {
                    "user": "certik",
                    "date": "2020-03-23 18:49:37+00:00",
                    "text": "@everythingfunctional perfect. Let me know once you have something, and I'll test it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-28 18:31:28+00:00",
                    "text": "I'm going to go ahead and close this issue, since I think we've decided to stick with toml. Plus we're now moving forward in that direction."
                }
            ]
        },
        {
            "number": 43,
            "user": "everythingfunctional",
            "date": "2020-03-07 03:48:33+00:00",
            "title": "Add place to specify other libraries when building library",
            "text": "This completes all the necessary capabilities of the build system.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-09 03:32:59+00:00",
                    "text": "Next step is to start putting together fpm.toml files and code to read them."
                }
            ]
        },
        {
            "number": 42,
            "user": "everythingfunctional",
            "date": "2020-02-28 15:52:57+00:00",
            "title": "Bpr add build system",
            "text": "Can now build a single project. Assumes all files in the app directory are programs.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-28 16:15:59+00:00",
                    "text": "I tested it locally and it seems to work. Thanks!"
                }
            ]
        },
        {
            "number": 41,
            "user": "certik",
            "date": "2020-02-25 22:45:09+00:00",
            "title": "Test calling GFortran from Haskell",
            "text": "Tests the new builder on the example.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-28 17:27:18+00:00",
                    "text": "@everythingfunctional I think the build code in master failed on Windows: https://github.com/fortran-lang/fpm/pull/41/checks?check_run_id=475345857"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-04 04:16:07+00:00",
                    "text": "Got it to work on Windows. Problem was inconsistencies with file paths. At various places, Shake normalizes them to Linux form, but other things are still in Windows form."
                },
                {
                    "user": "certik",
                    "date": "2020-03-04 04:41:30+00:00",
                    "text": "@everythingfunctional thanks a lot for fixing it! I am really happy it works on Windows also."
                }
            ]
        },
        {
            "number": 40,
            "user": "everythingfunctional",
            "date": "2020-02-25 18:34:35+00:00",
            "title": "Switch to using Haskell",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-25 18:43:48+00:00",
                    "text": "The Linux and Mac works, the Windows fails due to mstksg/setup-stack#5. I am figuring a workaround."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 18:48:36+00:00",
                    "text": "@milancurcic: To describe our plan here: @everythingfunctional and I decided to join forces on FPM. Brad has already an implementation in Haskell of a subset of what we want FPM to do, and we decided to use his code to get the minimal viable version of FPM. So we'll do it in Haskell. It turns out Haskell's Stack is like Rust's Cargo, and both do what we want to achieve with FPM.\nOnce we have the minimal viable version working, we, as a community, will have to choose a language to implement this in for the long run (I still think Rust is not a bad option). But for now our goal is to get a minimal version out there, and the best is to join forces as much as we can."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-25 18:54:02+00:00",
                    "text": "Sounds good. I like Haskell as well. I was more interested in learning Rust though. However this is a practical decision and getting to MVP sooner is what matters.\nI only wish this was discussed in the open rather than decided under the table. Not so much about who makes the decision, but more about how and why are decisions made."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 19:04:34+00:00",
                    "text": "@milancurcic thanks for the comment. (Yes, I am personally more interested in learning Rust also.)\nI should have phrased it differently. We are working on the PR and once we are done with the PR, we would like to get a community agreement that this would be an ok path to get to the MVP. We have not made the decision under the table. Only if the community agrees, then we will merge the PR.\nThe downside is that Haskell is not as well known language. The huge upside is that now we have 2 developers (@everythingfunctional and myself) as opposed to just one developer (myself). And that, in my eyes, outweighs the slight negative of using a different language for the MVP.\nOnce MVP is out, we would need to decide what language to use for the long run. (I think I would prefer either C++ or Rust for that.)"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-25 19:16:03+00:00",
                    "text": "Thanks for clarifying that, sounds like a good plan."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 19:49:57+00:00",
                    "text": "Tests pass. This is currently just a bare bones Haskell project, but it runs on Linux, macOS and Windows.\n@milancurcic would you be ok with merging this PR now? It would help us to develop faster --- have a master that passes tests everywhere and we can quickly send PRs to get the features implemented. The Rust version is still there in the archive directory if we every wanted to come back to it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-02-25 19:51:27+00:00",
                    "text": "I think we can have some MVP within the week. If things go wrong or the community would rather switch back to using Rust or something else, we can always switch back to that."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-25 19:58:00+00:00",
                    "text": "This is fine with me. As I'm not actively engaged yet, I don't have much say. But I also don't foresee issues when I do start contributing. So please go ahead with whatever you find is the best way forward and keep discussing."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 22:08:44+00:00",
                    "text": "Thanks @milancurcic! We'll keep you updated."
                }
            ]
        },
        {
            "number": 39,
            "user": "certik",
            "date": "2020-02-24 21:56:43+00:00",
            "title": "Package layout",
            "text": "We've been working with @everythingfunctional on the standardization of the layout. First iteration:\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 b\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90\n    \u2514\u2500\u2500 utils.f90\n\n2 directories, 4 files\n$ cat fpm.toml \nName \"a\"\n$ cat src/a.f90 \nmodule a\nuse a_utils, only: util1\nuse a_b_utils, only: util2\n\nimplicit none\nprivate\npublic util1, util2\nend module\n$ cat src/utils.f90 \nmodule a_utils\nimplicit none\nprivate\npublic util1\n\ninteger :: util1\n\nend module\n$ cat src/b/utils.f90 \nmodule a_b_utils\nimplicit none\nprivate\npublic util2\n\ninteger :: util2\n\nend module",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-24 23:17:07+00:00",
                    "text": "Here is a second iteration of the above layout:\n$ tree .\n.\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 main.f90\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 b\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 x\n    \u2514\u2500\u2500 x.f90\n\n5 directories, 6 files"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 17:22:34+00:00",
                    "text": "I'm really confused now.\n\nThis thread doesn't say that the source file should have the same name as the module;\nIt actually implies that it can be different, e.g. utils.f90 defines module a_utils.\nfpm can't build this example because of #57.\n\nSo based on feedback so far, I assume that source file should be named the same as the module, and perhaps the spec in this thread is out of date. Then you have (ignoring app and x.f90 for simplicity):\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 a_utils.f90\n    \u2514\u2500\u2500 b\n        \u2514\u2500\u2500 a_b_utils.f90\n\n2 directories, 4 files\n\nNow the source files have the same name as the modules they define. This doesn't work either because fpm builds b_a_b_utils.o out of src/b/a_b_utils.f90:\n# gfortran (for build/debug/library/a_utils.o build/debug/library/a_utils.mod)\n# gfortran (for build/debug/library/b_a_b_utils.o build/debug/library/b_a_b_utils.mod)\nfpm-exe: Error when running Shake build system:\n  at want, called at src/Build.hs:188:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/package-name.a\n  at need, called at src/Build.hs:186:13 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/b_a_b_utils.o\n  at &%>, called at src/Build.hs:166:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/b_a_b_utils.o build/debug/library/b_a_b_utils.mod\n  at error, called at src/Development/Shake/Internal/Rules/Files.hs:245:13 in shake-0.18.5-44KSA7uQF2VObxzEvLYZx:Development.Shake.Internal.Rules.Files\n* Raised the exception:\nError, &%> rule failed to produce 1 file (out of 2)\n  build/debug/library/b_a_b_utils.o\n  build/debug/library/b_a_b_utils.mod - MISSING\n\nOkay, so fpm does some renaming of files under the hood--b/a_b_utils.f90 compiles to b_a_b_utils.f90. But the compiler emits a_b_utils.mod and fpm expects b_a_b_utils.mod.\nA-ha! Maybe I need to call my module b_a_b_utils:\n$ head -1 src/b/a_b_utils.f90 \nmodule b_a_b_utils\n\nGreat, fpm now builds correctly.\nPerhaps this is what Brad meant in #57 when he said\n\nwe want the file name to match the module name, and the module name to include the path components of the file name.\n\nI didn't understand this because the 1st half of the sentence conflicts the 2nd half of the sentence.\nBut I think the 2nd half is key: If you have src/a/b/c/utils.f90, then the module should be called a_b_c_utils.\nGiven this, perhaps I can reverse engineer the correct spec. Let's try a third iteration:\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 b\n    \u2502   \u2514\u2500\u2500 b_utils.f90\n    \u2514\u2500\u2500 utils.f90\n\nThen, the contents are:\n$ cat src/a.f90 \nmodule a\nuse utils, only: util1\nuse b_b_utils, only: util2\n\nimplicit none\nprivate\npublic util1, util2\nend module\n$ cat src/utils.f90 \nmodule utils\nimplicit none\nprivate\npublic util1\n\ninteger :: util1\n\nend module\n$ cat src/b/b_utils.f90 \nmodule b_b_utils\nimplicit none\nprivate\npublic util2\n\ninteger :: util2\n\nend module\n\nfpm builds this correctly.\nNow, if I went through this much trouble to figure this out with help from fpm developers, imagine other people trying to build their thing with fpm. :)\nWe need a clear, clean, explicit spec."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 17:34:12+00:00",
                    "text": "@everythingfunctional and I discussed this, and the solution that we both liked in the end is precisely as I posted above (which is different to your comment), I just didn't have time to write it more explicitly. @milancurcic, please help us, we are doing what we can in our little time. If you have time, please help us write the spec.\nThe most natural way seems to have a file src/a/b/utils.f90, which means a package \"a.b\", and module \"a.b.utils\" (using Python syntax). However, in Fortran we do not have nested packages, until j3-fortran/fortran_proposals#86 is implemented. But what we can do now is to put the package name in the name of the module, so the file src/a/b/utils.f90 would start with module a_b_utils and fpm would check / enforce it. To move files around, you can simply move them, and fpm will have a mode to rename the first module line correctly.\nWhat you are proposing is to name the file as src/a/b/a_b_utils.f90 which is redundant and we feel it would be quite a pain to keep correctly named. It's much easier to simply call it src/a/b/utils.f90. However, the first module line must have the full name, to disambiguate src/a/utils.f90 from src/a/b/utils.f90.\nNow we are just working on fpm to work like this. If there are some bugs, then we need to fix them.\nIn particular, we need to write more tests, which would clarify what is meant to work."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-27 17:38:11+00:00",
                    "text": "Ok, yeah. Here's what I think the specification about that would be.\nfpm replaces the path separators with underscores when determining the name of the .o file to be created when compiling a given source file. For modules, it also expects compiling that source file to create a .mod file with the same name as the .o file. This means that a source file a/b/utils.f90 should contain a module named a_b_utils.\nI'm sure this could use a bit more wordsmithing or clarification. It also needs to be fit into a larger specification about the expected (default) organization of an fpm compatible project, with instructions about how to override the defaults."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 17:57:01+00:00",
                    "text": "@milancurcic, please help us, we are doing what we can in our little time. If you have time, please help us write the spec.\n\nWhat do you think I'm doing? :)\n\nWhat you are proposing is to name the file as src/a/b/a_b_utils.f90 which is redundant and we feel it would be quite a pain to keep correctly named. It's much easier to simply call it src/a/b/utils.f90. However, the first module line must have the full name, to disambiguate src/a/utils.f90 from src/a/b/utils.f90.\n\nI don't propose that, it's how I originally understood Brad, but that's not what he meant and I understood it later. What led me astray is that the 2nd iteration of your tree wasn't consistent with the module names in the original post.\nBased on the feedback, here's the package structure (same as Ondrej's 2nd iteration):\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 a_utils.f90\n    \u2514\u2500\u2500 b\n        \u2514\u2500\u2500 utils.f90\n\n2 directories, 4 files\n\nAnd here are the contents:\n$ cat src/a.f90 \nmodule a\nuse a_utils, only: util1\nuse a_b_utils, only: util2\n\nimplicit none\nprivate\npublic util1, util2\nend module\n$ cat src/a_utils.f90 \nmodule a_utils\nimplicit none\nprivate\npublic util1\n\ninteger :: util1\n\nend module\n$ cat src/b/utils.f90 \nmodule a_b_utils\nimplicit none\nprivate\npublic util2\n\ninteger :: util2\n\nend module\n\nDoes this look correct?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 18:17:27+00:00",
                    "text": "Almost. You are still putting the prefix into the filename in a_utils.f90. It should look like in #39 (comment). So put a_utils.f90 into a/utils.f90.\nI also had the b module nested under a, but that just depends what you are trying to show. Both can be done."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 18:27:00+00:00",
                    "text": "Oops, you're right, I did that. If we ignore src/x* and app, we get:\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 b\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90 # module a_b_utils\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90 # module a_utils\n    \u2514\u2500\u2500 a.f90 # module a\n\n3 directories, 4 files\n\nI put module names as # comments next to each file. I think this is correct now and I agree with it.\nIf you agree, I'll submit a PR to document this."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 18:32:28+00:00",
                    "text": "Btw, current master of fpm builds this correctly."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 19:04:45+00:00",
                    "text": "@milancurcic yes, if you could please document this and the reasoning behind this decision, that would be awesome. I am really happy you agree with this also. It's different to what I've been used to doing, but only in the fact that each module has the full name in the module line (and when you think about it, it makes sense to do it that way until j3-fortran/fortran_proposals#86 is implemented). Otherwise I've seen lots of projects structured in directories like this."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-27 20:38:49+00:00",
                    "text": "It looks like we're on the same page now. Thanks for struggling through this @milancurcic . I know we didn't do a very good job documenting it, so your efforts are hugely appreciated."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:30:00+00:00",
                    "text": "I think this is pretty well settled now. Should we close this?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 05:25:10+00:00",
                    "text": "We should document these choices and why we chose it. Then we can close this. Because this will come up again.\n\u2026\nOn Wed, Apr 29, 2020, at 9:30 PM, Brad Richardson wrote:\n\n\n I think this is pretty well settled now. Should we close this?\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#39 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWES7J5OW4SJVYLBDYLRPDWENANCNFSM4K2TQKOQ>."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 06:41:18+00:00",
                    "text": "This issue does not have much info anyway and it is documented in the tutorial a bit, so let's close this one."
                }
            ]
        },
        {
            "number": 38,
            "user": "certik",
            "date": "2020-02-23 18:31:31+00:00",
            "title": "Implement common_prefix",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-23 18:40:48+00:00",
                    "text": "There is a failure on Windows due to / vs \\. I am glad we test it. I have to investigate and fix it."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 06:53:58+00:00",
                    "text": "I am going to close this one for now."
                }
            ]
        },
        {
            "number": 37,
            "user": "certik",
            "date": "2020-02-20 21:37:08+00:00",
            "title": "CI: Do not install GFortran (already present)",
            "text": "Implemented in actions/virtual-environments#202 (comment).",
            "comments": []
        },
        {
            "number": 36,
            "user": "certik",
            "date": "2020-01-31 19:59:25+00:00",
            "title": "How to handle packages that do not have `fpm.toml`",
            "text": "There will be a lot of packages that do not have fpm.toml. Here is my suggested approach how to handle that:\n\n\nEncourage every package to use fpm.toml and to use fpm.\n\n\nThose packages that do not use it yet could be handled as follows: we will maintain a version (fork) at GitHub or GitLab that includes the fpm.toml. It will be this fork that would be used with fpm. From fpm's perspective, each package always contains fpm.toml.\n\n\nThe alternative to (or modification of) 2. is to allow fpm.toml to specify where to find sources of the actual package. So our GitLab package can be just one file fpm.toml that would list the metadata and where to download the sources plus any patches to them.\n\n\nIn particular, here is my plan: I will start with forking the packages listed at #17 and implementing fpm.toml together with any modifications that might be needed. I will not submit a PR back initially, but rather simply get my forks working well with fpm, and test it all out and get some usage. Then, as things start to get more serious and the fpm tool matures, we can easily send a PR against the upstream package and start the discussion with upstream authors if they would be willing to use fpm and maintain fpm.toml themselves. And depending on how this conversation goes, we'll either do just 2., or if we need to, we can also implement 3. in fpm. I expect that upstream authors will give us a list of features that they need fpm to have implemented, and once we do, they would be willing to use it.",
            "comments": []
        },
        {
            "number": 35,
            "user": "certik",
            "date": "2020-01-31 19:25:52+00:00",
            "title": "Full package registry",
            "text": "After #34 is implemented, we can discuss how to implement a full package registry similar to https://crates.io. It would be an extension of #34, which would also include hosting of the tarballs, and collecting usage statistics and other things. I think the solution in #34 can be evolved into this.",
            "comments": []
        },
        {
            "number": 34,
            "user": "certik",
            "date": "2020-01-31 19:22:34+00:00",
            "title": "Minimal metadata registry",
            "text": "After #33 is implemented, the next step is to implement a minimal metadata registry. Here is one way to do that:\n\nHave repository https://github.com/fortran-lang/package-registry that would contain a simple JSON file of this form which is the package registry:\n\n[{\n    \"name\": \"stdlib\",\n    \"versions\": [\n        {\"version\": \"0.3.4\", \"url\": \"https://github.com/fortran-lang/stdlib/archive/0.3.4.tar.gz\"},\n        {\"version\": \"0.3.5\", \"url\": \"https://github.com/fortran-lang/stdlib/archive/0.3.5.tar.gz\"},\n    ]\n}, {\n    \"name\": \"bspline\",\n    \"versions\": [\n        {\"version\": \"6.0.0\", \"url\": \"https://github.com/jacobwilliams/bspline-fortran/archive/6.0.0.tar.gz\"},\n        {\"version\": \"5.4.2\", \"url\": \"https://github.com/jacobwilliams/bspline-fortran/archive/5.4.2.tar.gz\"},\n    ]\n}]\n\n\nWe will then have scripts that take this JSON file and download the actual metadata for each package version. So for example, to obtain the metadata for the package bspline version 5.4.2, it would download the tarball https://github.com/jacobwilliams/bspline-fortran/archive/5.4.2.tar.gz, unpack and it would read its fpm.toml, which would contain all the metadata such as short and long description, the list of dependencies, and other things. Then we can automatically create a website which would list all this metadata. This generated website would contain a generated file metadata.json, which the fpm tool can then download to obtain a searchable data base of packages (fpm search).\n\n\nTo add a new package to registry, just a new simple entry must be made to the above JSON file by hand, say by issuing a PR against the repository.\n\n\nLater we can automate things more, similarly to how conda-forge works (https://conda-forge.org/docs/maintainer/adding_pkgs.html), where to put a new package in, a PR is sent against https://github.com/conda-forge/staged-recipes/, where the CI checks initial quality and that the package builds, and then if it gets merged, the CI actually creates a new repository for the package etc. In our case, we could have a staging repository, and if a PR is merged, the CI would correctly update the above JSON file.\n\n\nWe can discuss if the JSON file should also contain all the metadata from fpm.toml directly. The advantage of the above approach is that it is not redundant, the JSON only contains the minimal amount of information that can be edited and maintained by hand, and if you want more, you download the tarball and read its fpm.toml, which will be done automatically in the step 2.\nOverall, this minimal package registry only contains a minimal JSON file. The actual tarballs and metadata are hosted elsewhere. After this is well implemented and works, we can evolve it into a full package registry (#35).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-31 19:35:29+00:00",
                    "text": "The thing to discuss here, which we didn't have to worry about in #33 is what to do if multiple people want to have a bspline package. Should we require to prefix it with the github organization/user name, as in jacobwilliams/bspline, or what do we do if somebody submits (registers) the bspline name, but there will later be a better, more widely used and popular bspline package. If we simply switch the url for bspline from the old package to the new package, then all kinds of packages that already depend on the old bspline package would break. One approach could be that since most Fortran packages will be in this ecosystem, we would know which packages depend on it, so we could correctly update them all (and rename bspline to bspline_legacy). For example Debian had to rename the git package, as it wasn't the usual git, but some older package that just happened to be called git before the version control system came along. In our case I can see this happening for every popular package name such as \"mesh\", \"utils\", \"spline\", ... So we should have some policy how to handle such things. One such policy can be that we would evaluate the usage and a number of github stars, and allow the most used package to have the more popular name."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-31 19:49:28+00:00",
                    "text": "Great, thanks! The step 2 in the proposed flow assumes that the package will include its fpm.toml. However, this is only possible if the package has an active maintainer that is willing to maintain the package-specific fpm.toml. Would this not preclude fpm from downloading tarballed packages from the wild, like SOFA for example?\nIf the community maintains all metadata needed to download and build the package in the registry, it would broaden the ecosystem of packages fpm could work with."
                },
                {
                    "user": "certik",
                    "date": "2020-01-31 20:00:58+00:00",
                    "text": "@milancurcic your last comment seems to be a bit orthogonal issue, so I created #36 for it to discuss just this aspect of how fpm is designed."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-10 18:52:48+00:00",
                    "text": "Now that there's a package that can be built with fpm, let's revisit this issue which is a requirement for installing a package from a remote location such as a GitHub repo.\nI think @certik's idea of a minimal registry is a good start. We'll also need a description field, so that fpm list not just names of packages, but also there (one-line) descriptions, just like other package managers.\nAnother doubt I have is whether this should be a separate repository, rather than part of this repository. In my opinion, keeping it in this repo is simpler because:\n\nOne doesn't need to maintain a separate repo for the registry\nLess confusing for newcomers--there's only one repo (this one), whether you want to contribute to the code, or submit a package to the registry\nIssues+PR system allows clean separation between fpm issues and package submissions to the registry. So we don't need to separate them in another way.\n\nfpm would need to update its registry cache in either approach.\n@certik are there benefits of having a registry in a separate repo, or is it more an esthetic thing?\n\nSeparate vs. same repo question aside, how would this look like from the UI perspective? For simplicity, let's forget about search for now. Let's say we just want to be able to list available packages. This could be something like:\nfpm list\n  datetime-1.7.0 -- Date and time manipulation\n  openblas-0.3.9 -- Optimized BLAS library based on GotoBLAS2\n  stdlib-0.1.0 -- Fortran standard library\n\nUnder the hood, fpm:\n\nFetches the registry\nParses it\nLists individual packages and latest version so you get the above\n\nWe can discuss how to list individual available versions at a later time. Let's try to solve the minimal problem first."
                },
                {
                    "user": "certik",
                    "date": "2020-05-10 19:13:31+00:00",
                    "text": "My initial gut feeling is not to put packages in this repository. Although Spack does it like that and I think it works for them.\n\nEither way, fpm needs to download the packages from the internet, unless we do it like Spack, which reads them from a local repository checkout.\n\nI think since we are in a prototype mode, let's just put everything in this repo. Get things working for a few packages with dependencies and then let's figure out what to do for production version of fpm.\n\nLet's also understand well how Cargo does it and why something does not work for us. Let's also document our reasoning.\n\u2026\nOn Sun, May 10, 2020, at 12:53 PM, Milan Curcic wrote:\n\n\n Now that there's a package that can be built with fpm\n <https://github.com/wavebitscientific/datetime-fortran>, let's revisit\n this issue which is a requirement for installing a package from a\n remote location such as a GitHub repo.\n\n I think @certik <https://github.com/certik>'s idea of a minimal\n registry is a good start. We'll also need a description field, so that\n fpm list not just names of packages, but also there (one-line)\n descriptions, just like other package managers.\n\n Another doubt I have is whether this should be a separate repository,\n rather than part of this repository. In my opinion, keeping it in this\n repo is simpler because:\n\n  * One doesn't need to maintain a separate repo for the registry\n  * Less confusing for newcomers--there's only one repo (this one),\n whether you want to contribute to the code, or submit a package to the\n registry\n  * Issues+PR system allows clean separation between fpm issues and\n package submissions to the registry. So we don't need to separate them\n in another way.\n fpm would need to update its registry cache in either approach.\n\n @certik <https://github.com/certik> are there benefits of having a\n registry in a separate repo, or is it more an esthetic thing?\n\n Separate vs. same repo question aside, how would this look like from\n the UI perspective? For simplicity, let's forget about search for now.\n Let's say we just want to be able to list available packages. This\n could be something like:\n\n `fpm list\n   datetime-1.7.0 -- Date and time manipulation\n   openblas-0.3.9 -- Optimized BLAS library based on GotoBLAS2\n   stdlib-0.1.0 -- Fortran standard library\n `\n Under the hood, fpm:\n\n  1. Fetches the registry\n  2. Parses it\n  3. Lists individual packages and latest version so you get the above\n We can discuss how to list individual available versions at a later\n time. Let's try to solve the minimal problem first.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#34 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGTEEJIDXEN5FKTROTRQ3ZYZANCNFSM4KOMKF7A>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 02:33:50+00:00",
                    "text": "I think we should do what Cargo does with crates.io and have a separate repository for packages. Packages are stored there as tarballs and you can interact with it via a simple REST API. This gives us several advantages.\n\nWe can put certain checks in place for packages published to the official repo\nAnyone else can stand up their own repo, and just conform to the same API (i.e. private repos). We can even open-source the code for it\nAnyone else can write whatever tools they like to interact with it\n\nUntil we can get such a service stood up, we should endeavor to keep a list in the fpm README of known packages"
                },
                {
                    "user": "certik",
                    "date": "2020-05-11 13:31:39+00:00",
                    "text": "@everythingfunctional what you are proposing is #35. I think we all agree on that one. We also agree that is a lot of work, and so right now we are discussing what to do until we get there.\nSo far the proposals are:\n\nDocument available packages in the README\nCreate a manual metadata registry (this issue #34)\n\nI think we should definitely try the manual metadata registry, not just a README, as it would allow us to almost get the full experience of #35.\n\nProgressing the discussion further, I proposed above how such a JSON file (if we use JSON) could look like. Milan suggested it also needs a description field. I don't think that's a good idea for the following reasons:\n\nThe description is another thing to handle manually\nIt can change between versions, so it would have to be attached to each version\nIt's duplicate from the upstream package's toml file, another thing to keep in sync.\n\nThe reason I think why Milan proposed it is to make it possible for fpm to print packages with more information about them. I agree fpm should be able to do that, but not in the above proposed way.\nThe same with putting this metadata in this repository.\nRather, we should plan out how to we get to fixing #35. And then in this issue we should do work that is aligned with it.\nSo here I am proposing a draft of such a plan:\n\nThe issue #35 is mainly about hosting tarballs. But everything else about the registry can be done as part of this issue\nHave a separate repository called fpm_registry\nThe fpm_registry will have a JSON file (with the format above)\nTo submit a package (version) to the registry, people send a PR towards fpm_registry to update the JSON file ---- and just like when submitting to pypi or crates, you do not fill out a separate description field, you should not here either --- that gets filled out automatically from fpm.toml (see below)\nThen we have a separate repository plus CI pipeline that automatically takes this JSON file and:\n\ndownloads each package (it can cache old info, so only needs to download new packages), extracts full metadata (description, dependencies, etc.) and uses that information to:\ncreate a nice website with a page for each package that looks like crates.io (has a description, links to dependencies, and any other useful metadata extracted from fpm.toml)\ncreate a \"registry JSON\", which has full metadata for each package, including description\n\n\nfpm gets updated to be able to download this \"registry JSON\" from this auto generated website, and use this \"registry JSON\" to print info about packages, what packages depend on, etc.\n\nThen later on, to take this to implement the full #35, the only thing missing really is just hosting of tarballs. Everything else I think can be reused.\nThe above plan also allows other people (companies) to host their own registry\n\nThe above plan can be started by simply:\n\ncreate an fpm_registry with the minimal JSON\nadd a CI that takes this JSON and creates \"registry JSON\" and hosts it online\nupdate fpm to download and work with this \"registry JSON\"\n\nThese are three simple steps that I can even help implement, I've done something similar for LFortran. This can then be naturally expanded to also create a nice website."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 14:20:14+00:00",
                    "text": "I like that plan. It's usable to the point that even if we don't end up moving to a tarball hosting registry, I don't think anybody would even mind."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-11 15:44:57+00:00",
                    "text": "I like this plan as well. So actually this minimal registry is not what's read by fpm, but is read by another program that outputs the \"production\" registry with complete information. This is a good idea because then we don't have to assume ahead of time what is all the metadata that we'll need.\nI realize now that this issue is a step 2 from a 3-step #33. I will write there for now."
                }
            ]
        },
        {
            "number": 33,
            "user": "certik",
            "date": "2020-01-31 04:18:26+00:00",
            "title": "Decentralized package management",
            "text": "Rust allows the packages to be decentralized, they do not have to be listed at https://crates.io/.\nThe Go language does not even have a centralized package registry at all, see this blog post that explains it in the section \"Package Management\":\nhttps://nullprogram.com/blog/2020/01/21/\n\nModules are named by a module path that includes its network location. This means there\u2019s no land grab for popular module names.\n\nI don't like the Go's model that the name of the package is the url, I prefer the Rust model where a package has a simple name, but you specify where it can be downloaded. The end result is the same. (Overall, the Rust package management seems much more thought out, and it seems they fixed the issues that Go is tackling long time ago.)\nI want to implement the same approach for fpm. That will allow us to build an ecosystem of packages for Fortran, without a \"goldrush\" to reserve a popular package name in a centralized registry. Then, as we have a healthy ecosystem of packages, we can add a centralized registry later.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-31 18:45:30+00:00",
                    "text": "Overall I like this direction. However I'm confused about how this works in practice. Perhaps it's just a terminology issue.\nLike PyPI, Crates serves both as a registry (metadata), and code distribution.\nI agree that it's not feasible for fpm to host and distribute code. It's a huge ordeal and technical challenge.\nHowever, do you also mean that fpm wouldn't have a centralized metadata registry? If yes, how would a newcomer to Fortran and fpm search for packages? It seems to me that if you don't have some centralized metadata registry, the user would need to know what package they need and how to download it."
                },
                {
                    "user": "certik",
                    "date": "2020-01-31 19:44:11+00:00",
                    "text": "I think it's a step by step process, we start with the step 1. below, then we progress to step 2. and then to step 3.:\n\n\nThis issue #33: indeed there is no centralized metadata registry. The advantage is that there is no \"goldrush\" to reserve popular names in a centralized registry. Initially there is no package search (newcomers must know the package name), but I can imagine actually creating a search --- all we need for people to submit urls of packages out there, and since each is using fpm.toml, we can then create a search of those decentralized packages.\n\n\nIssue #34: minimal centralized registry. Allows a natural fpm search capability.\n\n\nIssue #35: both registry and code distribution.\n\n\nIf step 1. is fully developed, there can actually be a \"decentralized package registry\". It would work just like described in step 2. (see the issue #34 for details), except that there would not be a centralized name for a package, so people could submit various packages (as url) that can have the same name. Then fpm search would give you all the packages with urls to put into your fpm.toml. We can curate this list as a community to prevent spam and malicious code."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-11 15:51:08+00:00",
                    "text": "Coming from #34, let's discuss how the step 1 (no centralized registry) works. This means we don't need fpm search and fpm list.\nLet's say I just want to fpm install with datetime-fortran as a dependency. I know the name of the package. I don't (and shouldn't) know the URL of the package.\n@certik How does this work? It seems to me that we need some metadata even at this stage.\nOr is the user expected to enter something like:\n[dependencies]\nname = \"datetime\"\nurl = \"https://github.com/wavebitscientific/datetime-fortran\"\nto their fpm.toml?\nBoth approaches seem okay to me for now (latter is simpler), I'm just not clear what's your idea how this works."
                },
                {
                    "user": "certik",
                    "date": "2020-05-11 16:11:38+00:00",
                    "text": "The step 2 in #34 is what we should eventually do, and then step 3 in #35. It looks like we got agreement on both.\nYou can only install datetime-fortran (btw, it should probably just be called datetime) without knowing the url at the step 2., because you need the registry to get the url.\nSo let's start with step 1 in this issue #33. In here I propose to do exactly what Cargo does. Say I want to use datetime in my program. Here are details about Cargo's syntax: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html, so let's do what they do:\nI would have this in my fpm.toml:\n[dependencies]\ndatetime = \"1.7.0\"\nOnce step 2 is implemented, then fpm would have a default registry, and you can also specify your own registry either on a command line or explicitly:\n[dependencies]\ndatetime = { version = \"1.7.0\", registry = \"my-registry\" }\nUntil then, in this step 1, we do not have a registry, so you have to also tell it where it can download the datetime package directly. As explained at the webpage, Cargo only uses the version field if it downloads from a registry, otherwise it ignores it if it downloads it directly from a git repository or a local path. We can start with that approach, if we need more, we can modify that behavior. So here is how you would do it:\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\", tag = \"v1.7.0\" }\nHowever, since we want to move to a registry, and since most projects follow the convention of prefixing the version by v in the git tag (I do in all my projects, and I noticed you do too), I am proposing this natural extension of what Cargo does:\n\nIf git and version is specified, it will checkout a tag named v + version from that git repository\n\nSo with this extension, you would do:\n[dependencies]\ndatetime = { version = \"1.7.0\", git = \"https://github.com/wavebitscientific/datetime-fortran\" }\nAnd then later once we move to a registry, you just remove the git field, but keep the version and it would do the right thing."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 16:27:04+00:00",
                    "text": "Cargo actually has a different meaning for this:\n[dependencies]\ndatetime = { version = \"1.7.0\", git = \"https://github.com/wavebitscientific/datetime-fortran\" }\nThis means that when working in this package, it will download the latest master version of datetime, but for a package that depends on this one, the transitive dependency is version 1.7.0 of datetime from the default registry.\nI'm not saying we definitely shouldn't do what you're suggesting, but if we do it will preclude us from ending up with the same functionality as Cargo. It would also impose a tagging convention on people's repositories that will be unnecessary once we have a proper registry. Also, relying on git tags for official release version identifiers is wide open for abuse."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-11 16:51:00+00:00",
                    "text": "Perfect, this is what we're after as a first step:\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\", tag = \"v1.7.0\" }\nThis alone will already be a huge improvement over the current state of things.\nWe can work out the nuances of version and registry behavior as we go."
                },
                {
                    "user": "certik",
                    "date": "2020-05-11 16:53:16+00:00",
                    "text": "@everythingfunctional I am glad you noticed that. Let's not do my proposal then, just use tag. I think it is good enough and we will have a minimal registry soon anyway."
                }
            ]
        },
        {
            "number": 32,
            "user": "certik",
            "date": "2020-01-28 06:37:38+00:00",
            "title": "Implement dependencies",
            "text": "Just like in Cargo.\nWe should work on this after #25 is fixed.",
            "comments": []
        },
        {
            "number": 31,
            "user": "certik",
            "date": "2020-01-28 06:34:52+00:00",
            "title": "Add tests for different build directories",
            "text": "We need to add more tests:\n\n test that the default directory is target (in some temporary directory)\n test other locations of the build directory (will require to construct relative paths in CMakeLists.txt)",
            "comments": []
        },
        {
            "number": 30,
            "user": "certik",
            "date": "2020-01-28 05:54:47+00:00",
            "title": "Cleanup the test program",
            "text": "",
            "comments": []
        },
        {
            "number": 29,
            "user": "certik",
            "date": "2020-01-28 01:55:16+00:00",
            "title": "Use Command::new() instead of Command::cargo_new()",
            "text": "This seems to actually fix the issue #16 as documented at:\nhttps://users.rust-lang.org/t/github-actions-randomly-kill-a-test-program/37255/6",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-28 02:02:34+00:00",
                    "text": "I need to figure out how to obtain the absolute path to fpm in a platform independent way, and then pass it in. But this approach seems to be able to fix it."
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 04:59:06+00:00",
                    "text": "Tests pass. I am now testing that this truly fixes the macOS bug at certik#14."
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 05:34:37+00:00",
                    "text": "It works. I think this really fixed it! I am going to merge this and we'll watch it if it ever fails again."
                }
            ]
        },
        {
            "number": 28,
            "user": "certik",
            "date": "2020-01-25 17:44:14+00:00",
            "title": "Add Cargo.lock",
            "text": "This is the recommended approach for an application.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-25 18:29:18+00:00",
                    "text": "I was surprised by this, but indeed the docs recommend not committing Cargo.lock for a library and committing it for an application. Link for anybody like me who wondered about this:\nhttps://doc.rust-lang.org/cargo/faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries"
                }
            ]
        },
        {
            "number": 27,
            "user": "certik",
            "date": "2020-01-25 17:34:00+00:00",
            "title": "Install cmake using apt-get",
            "text": "",
            "comments": []
        },
        {
            "number": 26,
            "user": "certik",
            "date": "2020-01-18 17:31:51+00:00",
            "title": "Build in a target directory",
            "text": "Fixes #24.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-18 18:01:01+00:00",
                    "text": "I just need to fix it up on macOS and Windows."
                }
            ]
        },
        {
            "number": 25,
            "user": "certik",
            "date": "2020-01-18 15:05:48+00:00",
            "title": "Build in temporary directory for tests",
            "text": "After #24 and #31 is fixed, set the --target-dir to a temporary directory for tests. That way multiple tests can reuse the same source directory for different tests, in parallel.",
            "comments": []
        },
        {
            "number": 24,
            "user": "certik",
            "date": "2020-01-18 15:05:05+00:00",
            "title": "Put everything into target/",
            "text": "Put the CMakeLists.txt into target/, and ensure the source directory is not polluted at all.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-28 06:35:12+00:00",
                    "text": "The basic issue is fixed, but more tests need to be added (#31)."
                }
            ]
        },
        {
            "number": 23,
            "user": "certik",
            "date": "2020-01-18 15:00:29+00:00",
            "title": "Implement --target-dir",
            "text": "",
            "comments": []
        },
        {
            "number": 22,
            "user": "certik",
            "date": "2020-01-18 06:39:01+00:00",
            "title": "Parse fpm.toml",
            "text": "",
            "comments": []
        },
        {
            "number": 21,
            "user": "certik",
            "date": "2020-01-18 00:02:55+00:00",
            "title": "Print the full Rust stacktrace on error",
            "text": "",
            "comments": []
        },
        {
            "number": 20,
            "user": "certik",
            "date": "2020-01-17 23:36:35+00:00",
            "title": "macOS: repeat the test up to 2x if it fails",
            "text": "This is a workaround for #16. It turns out that if the executable fails\nto run, just rerunning all tests typically fixes it.",
            "comments": []
        },
        {
            "number": 19,
            "user": "certik",
            "date": "2020-01-17 20:30:08+00:00",
            "title": "CI repr 6",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-17 20:54:20+00:00",
                    "text": "My apologies, meant to create this one: certik#5"
                }
            ]
        },
        {
            "number": 18,
            "user": "certik",
            "date": "2020-01-16 05:56:24+00:00",
            "title": "Better reporting on terminated processes",
            "text": "This will eventually help fix #16.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-16 06:45:48+00:00",
                    "text": "I think this PR works as expected. In https://github.com/fortran-lang/fpm/pull/18/checks?check_run_id=392603247 it reports more information about the failure due to #16:\nrunning 3 tests\ntest test_help ... ok\ntest test_2 ... FAILED\ntest test_1 ... ok\n\nfailures:\n\n---- test_2 stdout ----\nstatus: signal: 9\nstdout: \nstderr: \n##[error]thread 'test_2' panicked at 'INTERRUPTED with signal: 9', tests/cli.rs:35:21"
                }
            ]
        },
        {
            "number": 17,
            "user": "certik",
            "date": "2020-01-15 22:18:24+00:00",
            "title": "Candidate packages to get working",
            "text": "Here are a few good candidate packages to get working with fpm first, that are relatively simple (and so possible to package soon), yet very useful.\nPure Fortran (Simple)\n\n https://github.com/wavebitscientific/functional-fortran\n https://github.com/jacobwilliams/bspline-fortran\n https://github.com/fortran-lang/stdlib\n https://github.com/astrofrog/fortranlib\n https://github.com/certik/fortran-utils/\n https://github.com/wavebitscientific/datetime-fortran\n https://github.com/jacobwilliams/pyplot-fortran\n\nPure Fortran (More Complex)\n\n https://github.com/Reference-LAPACK/lapack\n https://github.com/opencollab/arpack-ng\n https://github.com/jacobwilliams/json-fortran\n https://github.com/jacobwilliams/Fortran-Astrodynamics-Toolkit\n https://github.com/Goddard-Fortran-Ecosystem/pFUnit\n https://github.com/szaghi/StringiFor (Lots of dependencies)\n\nFortran with non-Fortran dependencies\n\n https://github.com/scivision/h5fortran\n https://github.com/scivision/nc4fortran\n https://github.com/SHTOOLS/SHTOOLS\n https://github.com/unidata/netcdf-fortran\n\nAnd obviously any other more complicated package from https://github.com/fortran-lang/stdlib/wiki/List-of-popular-open-source-Fortran-projects.\nAny other candidates?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-16 03:02:29+00:00",
                    "text": "I added nc4fortran and netcdf-fortran to the list."
                }
            ]
        },
        {
            "number": 16,
            "user": "certik",
            "date": "2020-01-15 15:02:32+00:00",
            "title": "The fpm binary gets interrupted at the CI (macOS)",
            "text": "There is a bug at our CI that I haven't been able to figure out yet. Here is an example of it: https://github.com/fortran-lang/fpm/runs/390475601.\nHere is what I know:\n\n\nIt only happens on macOS, never on Linux or Windows\n\n\nRestarting the build typically fixes it (sometimes it fails 2x or 3x in a row, but eventually it always passes)\n\n\nThe cargo test runs in parallel by default, so I set -j1 to run in serial. That seemed to improve how often it fails (although I could be wrong on that). It still fails sometimes however, so the actual bug is still there.\n\n\nThe error is:\n\n\nthread 'test_2' panicked at 'Unexpected failure.\ncode=<interrupted>\nstderr=``````\ncommand=`\"/Users/runner/runners/2.163.1/work/fpm/fpm/target/x86_64-apple-darwin/debug/fpm\" \"build\"`\ncode=<interrupted>\nstdout=``````\nstderr=``````\n', /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148:17\n\nWhich is caused by the assert_cmd package, which just uses the Rust's std::process::Command, when the output command did not succeed, but it also failed to retrieve the error code, which according to the documentation means the process was interrupted by the system (with some signal like SIGKILL).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-15 15:31:20+00:00",
                    "text": "And here it failed in master (https://github.com/fortran-lang/fpm/runs/391281163) after merging #15 that passed. So we have to figure this out."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 15:35:41+00:00",
                    "text": "Is there anybody with a Mac that can reproduce this locally?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 15:39:25+00:00",
                    "text": "I tried it on a macOS yesterday locally, and I can't reproduce it. So we have to Debug it at the CI itself (as I have done in #14), which is quite time consuming."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 06:48:29+00:00",
                    "text": "As reported in #18 (comment), the process gets interrupted with signal 9 (SIGKILL). I suspected that above, but it's nice to have a proof. For some reason macOS kills the fpm process."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 07:03:41+00:00",
                    "text": "This might be a bug at GitHub, so I reported it at https://github.community/t5/GitHub-Actions/GitHub-Actions-on-macOS-randomly-kill-my-test-program/m-p/43526#M5414."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 18:28:12+00:00",
                    "text": "I am trying to reliably reproduce this bug in certik#1."
                },
                {
                    "user": "certik",
                    "date": "2020-01-17 21:44:30+00:00",
                    "text": "One approach to fix this is to do cargo test || cargo test. An example where the first one fails, but the second one succeeds is https://github.com/certik/fpm/runs/396031403."
                },
                {
                    "user": "certik",
                    "date": "2020-01-17 21:56:03+00:00",
                    "text": "This is precisely the kind of issue I am a bit worried with Rust, that the toolchain is not mature enough and will produce binaries that do not work (but only sometimes!). The closest error that I was able to find is:\ngolang/go#19734"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-17 22:05:49+00:00",
                    "text": "But this likely has more to do with GitHub Actions than Rust itself. Neither you nor the person from the GitHub Forum could reproduce it locally, correct?\nI agree it's very important to have fpm work on all 3 major platforms, but I wonder if it's a bit too early to focus Mac OS work 100% of the time? Why not let it fail sometimes? We can manually trigger the build when it does fail."
                },
                {
                    "user": "certik",
                    "date": "2020-01-18 00:20:48+00:00",
                    "text": "I implemented a workaround in #20. The problem with GitHub Actions is that you cannot just restart a single build, you have to restart all the builds. The other issue is that it was already failing a lot with just 3 tests. Once we have hundreds of tests, it might end up failing all the time. For now the workaround implemented in #20 should make the CI robust enough for now. But we'll have to get back to this and fix it.\nThe reason I spent so much time on this is that I thought I can use \"bisection\" to create a minimal example that fails, and figure it out. But I failed. Essentially it's extremely unreliable to trigger the bug by submitting 20 commits. Sometimes they all pass, and sometimes they get 4 failures. And I haven't figured out a minimal example that can reliably trigger it in 20 runs. As I start removing things, the failures become less and less frequent.\nIf #20 doesn't give us reliable CI, then we can switch the macOS build to Azure pipelines or Travis-CI.\nBut having a reliable CI is a must."
                },
                {
                    "user": "certik",
                    "date": "2020-01-21 18:31:06+00:00",
                    "text": "I reported it in the Rust community also: https://users.rust-lang.org/t/github-actions-randomly-kill-a-test-program/37255"
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 05:35:21+00:00",
                    "text": "I think #29 fixed this issue."
                }
            ]
        },
        {
            "number": 15,
            "user": "certik",
            "date": "2020-01-15 05:42:54+00:00",
            "title": "Remove manual tests",
            "text": "Use \"cargo test\" instead.",
            "comments": []
        },
        {
            "number": 14,
            "user": "certik",
            "date": "2020-01-14 23:15:22+00:00",
            "title": "WIP: try to reproduce the error",
            "text": "",
            "comments": []
        },
        {
            "number": 13,
            "user": "certik",
            "date": "2020-01-14 21:20:21+00:00",
            "title": "Add Rust tests",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:39:55+00:00",
                    "text": "The Linux CI is currently broken at GitHub, but once they fix it, it should pass. The main problem that the macOS build was failing seems to be fixed by a571570. I am going to wait until the CI works again and rerun tests. Once they all pass, we can merge."
                },
                {
                    "user": "certik",
                    "date": "2020-01-14 23:08:53+00:00",
                    "text": "I tested almost 10x and the macOS built never failed, so I thought it was fixed. But now it failed twice in a row:\nrunning 3 tests\ntest test_help ... ok\ntest test_2 ... FAILED\ntest test_1 ... ok\n\nfailures:\n\n---- test_2 stdout ----\nthread 'test_2' panicked at 'Unexpected failure.\ncode=<interrupted>\nstderr=``````\ncommand=`\"/Users/runner/runners/2.163.1/work/fpm/fpm/target/x86_64-apple-darwin/debug/fpm\" \"build\"`\ncode=<interrupted>\nstdout=``````\nstderr=``````\n', /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148:17\n...\n\nThe CI is killing the runner for some reason, but I don't know why."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 04:30:59+00:00",
                    "text": "The macOS bug is still there, but by restarting the tests it typically fixes itself, so I am going to merge this and we'll eventually figure out what is causing it."
                }
            ]
        },
        {
            "number": 12,
            "user": "certik",
            "date": "2020-01-14 20:47:50+00:00",
            "title": "Draft: See if we get a failure",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:40:14+00:00",
                    "text": "Closing in favor of #13."
                }
            ]
        },
        {
            "number": 11,
            "user": "certik",
            "date": "2020-01-14 20:42:36+00:00",
            "title": "Add Rust tests",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:40:34+00:00",
                    "text": "Closing in favor of #13."
                }
            ]
        },
        {
            "number": 10,
            "user": "certik",
            "date": "2020-01-14 20:35:44+00:00",
            "title": "Prepare fpm to run on Windows using Rust tests",
            "text": "",
            "comments": []
        },
        {
            "number": 9,
            "user": "certik",
            "date": "2020-01-14 17:06:48+00:00",
            "title": "Run all tests using \"cargo test\" only",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 17:40:14+00:00",
                    "text": "Unfortunately there seem to be random errors on macOS of the type:\n---- test_help stdout ----\nthread 'test_help' panicked at 'Unexpected failure.\ncode=<interrupted>\nstderr=``````\ncommand=`\"/Users/runner/runners/2.163.1/work/fpm/fpm/target/x86_64-apple-darwin/debug/fpm\" \"--help\"`\ncode=<interrupted>\nstdout=``````\nstderr=``````\n', /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148:17\nstack backtrace:\n   0: backtrace::backtrace::libunwind::trace\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\n   1: backtrace::backtrace::trace_unsynchronized\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\n   2: std::sys_common::backtrace::_print_fmt\n             at src/libstd/sys_common/backtrace.rs:77\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\n             at src/libstd/sys_common/backtrace.rs:61\n   4: core::fmt::write\n             at src/libcore/fmt/mod.rs:1028\n   5: std::io::Write::write_fmt\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libstd/io/mod.rs:1412\n   6: std::io::impls::<impl std::io::Write for alloc::boxed::Box<W>>::write_fmt\n             at src/libstd/io/impls.rs:141\n   7: std::sys_common::backtrace::_print\n             at src/libstd/sys_common/backtrace.rs:65\n   8: std::sys_common::backtrace::print\n             at src/libstd/sys_common/backtrace.rs:50\n   9: std::panicking::default_hook::{{closure}}\n             at src/libstd/panicking.rs:188\n  10: std::panicking::default_hook\n             at src/libstd/panicking.rs:202\n  11: std::panicking::rust_panic_with_hook\n             at src/libstd/panicking.rs:464\n  12: std::panicking::continue_panic_fmt\n             at src/libstd/panicking.rs:373\n  13: std::thread::local::fast::Key<T>::try_initialize\n  14: assert_cmd::assert::Assert::success::{{closure}}\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148\n  15: core::option::Option<T>::unwrap_or_else\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libcore/option.rs:419\n  16: assert_cmd::assert::Assert::success\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:147\n  17: cli::test_help\n             at tests/cli.rs:9\n  18: cli::test_help::{{closure}}\n             at tests/cli.rs:6\n\nThis error only happens sometimes. So there might be some bug in the assert_cmd package on macOS."
                },
                {
                    "user": "certik",
                    "date": "2020-01-14 21:41:03+00:00",
                    "text": "Closing in favor of #13."
                }
            ]
        },
        {
            "number": 8,
            "user": "scivision",
            "date": "2020-01-14 16:43:19+00:00",
            "title": "cmake_minimum_required => 3.14",
            "text": "fpm/src/main.rs\n    \n    \n         Line 38\n      in\n      bf8ee01\n    \n    \n    \n    \n\n        \n          \n           cmake_minimum_required(VERSION 3.5.0 FATAL_ERROR) \n        \n    \n  \n\n\nThe CMake syntax used in this Rust script requires at least CMake 3.13.\nIn general in the Fortran stdlib we currently planned to use CMake 3.14 minimum.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:15:15+00:00",
                    "text": "Yes, it needs to be 3.14. Is the FATAL_ERROR needed? It seems to fail fatally even without it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:34:02+00:00",
                    "text": "This raises a broader issue about how should we handle minimum CMake version in fpm.\nShould we set a fixed minimum cmake version for all packages brought in by fpm (even if they are okay with an earlier version)? This seems like an unnecessary overkill to me.\nOr, should we let cmake do the work and have individual package builds fail if user's cmake is inadequate? I like this better.\nAre there other approaches?"
                },
                {
                    "user": "scivision",
                    "date": "2020-01-15 07:21:52+00:00",
                    "text": "if you intend to communicate with CMake beyond simple command line interaction, there was a significant improvement in CMake 3.14 adding a file based API. That would avoid having to implement that twice for CMake < 3.14 and the deprecated CMake server, if such communication is necessary for fpm.\nThis would allow for example to introspect CMake projects that don't use fpm, but are used by fpm."
                },
                {
                    "user": "scivision",
                    "date": "2020-01-15 16:35:19+00:00",
                    "text": "In my opinion the FATAL_ERROR parameter to cmake_minimum_version() can be omitted. It does nothing for CMake releases less than about 15 years old, and those with CMake that old would have trouble building almost anything for the past few years."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 19:21:08+00:00",
                    "text": "@scivision thanks. (I can't believe I've been using CMake longer than 15 years, but it seems I have...)\nRegarding the minimal version, it requires 3.14 for Windows, and I was thinking of simply using that for now everywhere.\nOnce fpm is further along, let's revisit this. Down the road I actually think fpm should be able to build things on its own, just like Cargo does it, which would be a lot faster (since cmake's configure phase can be pretty slow).\nFor now I just want to get some minimal product working, then we'll carefully revisit all these decisions."
                }
            ]
        },
        {
            "number": 7,
            "user": "certik",
            "date": "2020-01-14 15:46:23+00:00",
            "title": "CI: Test on Windows",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 16:10:13+00:00",
                    "text": "Tests pass, so I'll merge this. Futher work needs to be done on Windows, but this is a start."
                }
            ]
        },
        {
            "number": 6,
            "user": "certik",
            "date": "2020-01-14 06:08:41+00:00",
            "title": "How to support packages that do not conform to our \"standard layout\" (to be specified...)",
            "text": "How to support packages that do not conform to our \"standard layout\" (to be specified...). Some examples of such a package would be reference Lapack, or Arpack. The way to do that is that we create a new repository, say certik/lapack.fpm, which will have fpm.toml, in there it would specify the url to the actual sources (https://github.com/Reference-LAPACK/lapack) and a build script, which would build the sources (using CMake in this case) and install them into some $PREFIX provided by fpm and fpm takes it from there. This approach also works for non Fortran packages --- the build script either builds it, or requires it from the system (where it can be provided by, e.g., Spack). Either way this is a clean way to hook this up into the fpm ecosystem.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:40:11+00:00",
                    "text": "Yes, I think fpm.toml for each project should include the exact commands that need to be executed to build the package, very much like we do in yml files for CI.\nThat said, until a need arises, I'd suggest that we take this approach for all packages, including those built with CMake, autotools, or plain Makefiles.\nIf we can make a package build in CI, we should be able to build it by fpm by making it execute commands specified in fpm.toml.\n\nThe way to do that is that we create a new repository, say certik/lapack.fpm\n\nDoes this even need to be a separate repo? Are you thinking about a repo that would be the registry of all fpm-supported packages, like what I described in #4 ?"
                }
            ]
        },
        {
            "number": 5,
            "user": "certik",
            "date": "2020-01-14 06:08:04+00:00",
            "title": "Naming of `fpm.toml`",
            "text": "Naming of fpm.toml. Cargo names Cargo.toml with capital C, and as explained in https://doc.rust-lang.org/cargo/faq.html#why-cargotoml, to \"ensure that the manifest was grouped with other similar configuration files in directory listings. Sorting files often puts capital letters before lowercase letters, ensuring files like Makefile and Cargo.toml are placed together.\" If we want to do the same, the candidates are Fpm.toml and FPM.toml. I think fpm.toml looks better. But using a capital letter would make it similar to CMakeLists.txt also. We might want to devise a different name or naming scheme. Any ideas?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:30:36+00:00",
                    "text": "If we consider fpm.toml, I like it better than either Fpm.toml or FPM.toml. I see little value in the sorting argument.\nIf I think of any better names than fpm.toml, I will write here, but I think fpm.toml is just fine."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-01-15 08:25:24+00:00",
                    "text": "If I get it correctly in the Rust world libraries/packages are called crates, and the package manager called Cargo is responsible for shipping these crates?\nIn line with the Rust naming, if you don't mind playing with some old Fortran terminology, crates would become decks (as in punched card decks), and the Fortran package manager would be a box/package/drawer/folder/cabinet/chest/case/dealer/dispenser/pile/loader/...?.... Unfortunately none of these words really ring. The  fpm.toml acronym is also easy enough to remember.\nFrom Wikipedia:\n\n...a box of computer programs in punched card form from the early 1970s. The deck in the middle shows what a program deck looked like after extensive editing and debugging. The cardboard box was originally used to ship blank cards and held 2000 cards."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 05:22:26+00:00",
                    "text": "Thanks @ivan-pi for the ideas.\nI think a Rust package is simply called a crate, but even I am not 100% sure. For that reason I would recommend to simply call a package as a package, so that people know what that means.\nI agree, let's just use fpm.toml."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:28:15+00:00",
                    "text": "Should we close this now? We've implemented it as fpm.toml."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 05:25:31+00:00",
                    "text": "Yes, can be closed.\n\u2026\nOn Wed, Apr 29, 2020, at 9:28 PM, Brad Richardson wrote:\n\n\n Should we close this now? We've implemented it as `fpm.toml`.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#5 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWEQACM33QVEE66CTT3RPDV5XANCNFSM4KGNRUOQ>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 14:05:50+00:00",
                    "text": "Ok, closing."
                }
            ]
        },
        {
            "number": 4,
            "user": "certik",
            "date": "2020-01-14 06:07:30+00:00",
            "title": "Hosting of packages",
            "text": "Eventually we need to have a central place for packages similar to crates.io.\nBut for now we will use a git repository (GitHub, GitLab and other places will work) as well as just url for a tarball. That way we don't need to host anything ourselves at first and can get the initial community and ecosystem of packages built up without worrying about security and other issues that will come with maintaining our own repository.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:26:22+00:00",
                    "text": "Although worthwhile thinking ahead, I think we are far from this. It's a big technical challenge that requires dedicated hardware and person (people) if it's to work smoothly.\nIn the interim, as you describe, we can maintain a registry that provides all the info about available packages that fpm needs, but the source code of packages is hosted wherever its hosted by the package maintainers (GitHub, GitLab, custom url, whatever). The downside to this approach is that if the maintainer takes down the package, or changes the url, or GitHub is down, the package is unavailable through fpm. I think these are edge cases that we can live with and work around for a while, especially considering that Fortran's ecosystem is still fledgling.\nLet's discuss what would the registry look like. How about if we maintain a registry of fpm.toml files for each supported package in fpm's repo. Something like this:\nfpm/\n  Registry/\n    blas/\n      fpm.toml\n    lapack/\n      fpm.toml\n    stdlib/\n      fpm.toml\n    ...\n\nfpm.toml for a package includes all the info that fpm would need to build the package, including but not limited to:\n\nBuild backend such as CMake, autotools, or plan make\nGitHub, GitLab or custom url from which to download source code\nVersions available\nDependencies\nWhat else?\n\nFor a maintainer to add their package to fpm, they would open a PR in fpm to add their fpm.toml to the fpm Registry.\nAm I going in the right direction?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 05:13:52+00:00",
                    "text": "Actually, the registry would be just a list of urls to download the package, so:\nhttps://github.com/certik/lapack.fpm\nhttps://github.com/fortran-lang/stdlib\n...\n\nEach of these urls will be either a tarball, or a git repository. When you download it, it contains the fpm.toml file with all the metadata. And we'll have code that will simply download each package and extract the metadata to create a nice (static) webpage and to allow to search from a command line (fpm search) --- we can automatically prepare some JSON file with package name / description / url, etc., and host it at some github repo, and fpm would simply download it. (The registry might be a combination of version + url, because a single package can have multiple verisons, so one would use, e.g., git tags for different versions.)\nRegarding the design of fpm, I would do exactly what Rust does. So a standard layout (which however can be disabled if you don't like it from Cargo.toml), pure Rust is automatic, non-Rust parts are compiled by hand by writing a build script (and listing it in Cargo.toml, then Cargo executes it before building Rust parts). From the build script you can call cmake or whatever build system one wants."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 14:38:34+00:00",
                    "text": "Can you explain why you need a separate (middle-man) repo for metadata, per package?\nIf fpm gets metadata from one repo, which would then instruct it to download the package tarball from a custom url and build it with some commands, then it would have to do that transaction every time you inquire about a package. To not query a remote repo on every command, you'd want to cache results, which basically means you'd be building a local registry of packages. But if you're building a local registry of packages, you might as well maintain the registry in one repo.\nMore problematically, without a local (or remote but aggregated) registry, how do you search for available packages? With Cargo I can do:\n$ cargo search blas\nblas = \"0.20.0\"                   # The package provides wrappers for BLAS (Fortran).\ncoaster-blas = \"0.2.0\"            # Coaster library for full BLAS support\nrust-blas = \"0.1.1\"               # BLAS bindings and wrappers, fork of rblas\ncollenchyma-blas = \"0.2.0\"        # Collenchyma library for full BLAS support\nblas-src = \"0.4.0\"                # The package provides a BLAS source of choice.\nrblas = \"0.0.13\"                  # BLAS bindings and wrappers\nblas-sys = \"0.7.1\"                # The package provides bindings to BLAS (Fortran).\ncuda_blas = \"0.1.0\"               # cuBLAS API bindings.\npopcorn-blas = \"0.1.0\"            # Popcorn BLAS: Broadcasting BLAS operations for Popcorn\nnetlib-blas-provider = \"0.0.8\"    # BLAS/LAPACK provider using the Netlib implementation\n... and 54 crates more (use --limit N to see more)\n\nWould fpm search only list urls? Or would it try to fetch metadata from any number of repos that match the pattern? This won't scale.\nLooking at my local .cargo/ directory, it doesn't seem like Cargo keeps an index of all packages locally (for many many packages this doesn't scale either) but fetches from a remote registry (I assume cargo.io)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 14:42:22+00:00",
                    "text": "Regarding the design of fpm, I would do exactly what Rust does. So a standard layout (which however can be disabled if you don't like it from Cargo.toml), pure Rust is automatic, non-Rust parts are compiled by hand by writing a build script (and listing it in Cargo.toml, then Cargo executes it before building Rust parts). From the build script you can call cmake or whatever build system one wants.\n\nAre you saying that for pure Fortran code (like stdlib at the moment), you wouldn't use a build system but do the build explicitly by directly invoking the compiler? In the long run I think this is a good choice but I'm worried that it'd be a big ordeal to implement because now you have to worry about building dependency trees and all the necessary stuff that CMake was doing for us.\nOr, are you thinking about generating a CMakeLists.txt based on the scan of the source files and directories? Seems complex too."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 15:37:45+00:00",
                    "text": "Or, are you thinking about generating a CMakeLists.txt based on the scan of the source files and directories? Seems complex too.\n\nYes, that's how it is already implemented in this very small prototype of fpm. If you look here:\nhttps://github.com/fortran-lang/fpm/tree/master/tests/1\nAll you have to do is execute fpm build in that directory, and it will generate the proper CMakeLists.txt and build it and then fpm run will run the executable.\nThat's exactly how Cargo does it, and I think that's what we want also.\nAnd yes, I agree with you that using CMake as the vehicle to actually build it is the way to go initially. All fpm has to do is to construct it properly.\nIt already works, and my next step is to start doing the dependencies. Once we have a prototype of that, let's brainstorm how to host it properly. (Yes, I want fpm search to list names and descriptions just like Cargo does, so it needs to download some JSON description of all packages --- But what I am arguing is to maintain such JSON description automatically, not by hand, by downloading it from the actual packages --- we can discuss it later.)"
                }
            ]
        },
        {
            "number": 3,
            "user": "certik",
            "date": "2020-01-14 06:02:10+00:00",
            "title": "Remove GitLab-CI",
            "text": "We will use GitHub and its CI from now on.",
            "comments": []
        },
        {
            "number": 2,
            "user": "certik",
            "date": "2020-01-14 05:43:25+00:00",
            "title": "Build and run Rust tests",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 06:00:39+00:00",
                    "text": "Tests pass, merging."
                }
            ]
        },
        {
            "number": 1,
            "user": "certik",
            "date": "2020-01-14 05:38:24+00:00",
            "title": "Add GitHub CI",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 05:40:20+00:00",
                    "text": "I think it has to be merged first in order to run."
                }
            ]
        }
    ]
}